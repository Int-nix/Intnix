<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
<link rel="icon" type="image/png" href="favicon.png">





  <meta charset="UTF-8">
  <title>Intnix Webkernel</title>
  <style>
  body {
    background-color: #1e1e1e;
    color: white;
    font-family: monospace;
    margin: 0;
    padding: 10px;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }


  .prompt {
    color: #00ff88; /* Green prompt */
  }




  #terminal {
    max-height: 99vh;
    width: 100%;
    overflow-y: auto;
    white-space: pre-wrap;
  }

    .input-line {
      display: flex;
    }

    .prompt {
      margin-right: 5px;
    }

    .cmd-input {
      background: none;
      border: none;
 color: inherit; /* ‚úÖ Let JS set it dynamically */
      font-family: monospace;
      outline: none;
      flex: 1;
    }

    .window {
  position: absolute;
  width: 300px;
  background: #2e2e2e;
  border: 2px solid #00000000 ;
  box-shadow: 4px 4px 10px rgba(0,0,0,0.5);
  border-radius: 5px;
  overflow: hidden;
  font-family: monospace;
}


:root {
  --topbar-color: #3a7bd580;
}

.title-bar {
  background: var(--topbar-color);

 /* ~67% opacity */;
  color: #white;
  padding: 6px 10px;
  cursor: move;
  display: flex;
  justify-content: space-between;
  align-items: center;

}

.close-btn {
  background: transparent;
  border: 5px;
  color: #FF0000;
  font-size: 16px;
  cursor: pointer;
  font-style: bold;
}

.refresh-btn {
  background: transparent;
  color: #87CEEB;
  border: none;
  font-size: 14px;
  margin-right: 4px;
  cursor: pointer;
  transition: transform 0.2s;
}
.refresh-btn:hover {
  transform: rotate(90deg);
}


.min-btn {
  background: transparent;
  border: none;
  color: #ffffff;
  font-size: 16px;
  cursor: pointer;
  margin-right: 6px;
}

.max-btn {
  background: transparent;
  border: 2px solid #00ff00;
  width: 16px;
  height: 16px;
  cursor: pointer;
  margin-right: 6px;
  display: inline-block;
}


.window-content {
  width: 100%;
  height: 100%;
  overflow: auto;
  display: flex; /* or block/grid depending on your layout */
  box-sizing: border-box;
}


.suggestion-box {
   background: #2e2e2e;
   border: 1px solid #00ff88;
   border-radius: 4px;
   position: absolute;
   z-index: 1000;
   max-height: 200px;
   overflow-y: auto;
   font-family: monospace;
   color: white;
 }

 .suggestion {
   padding: 4px 8px;
   cursor: pointer;
 }

 .suggestion:hover, .suggestion.selected {
   background-color: #00ff88;
   color: #1e1e1e;
 }

 .input-container {
   position: relative;
   display: flex;
 }

  </style>

</head>
<body>
  <div id="terminal-original">
    <div id="terminal"></div>
  </div>

  <script>
  let isDebugging = false;
  let promptColor = "#00ff88"; // Default green
  let cutItem = null; // Holds the cut file/folder info
  const windowTracker = [];
  const dockOpenApps = new Set();

  function trackDockAppOpen(name) {
    dockOpenApps.add(name);
    window.postMessage({ type: "sync-dock-dots" }, "*");
  }

  function untrackDockApp(name) {
    dockOpenApps.delete(name);
    window.postMessage({ type: "sync-dock-dots" }, "*");
  }

  function getOpenDockApps() {
    return Array.from(dockOpenApps);
  }


  function trackDockItems() {
    const openDockApps = new Set();

    // Attach click listeners to each dock icon
    document.querySelectorAll(".dock-icon-wrapper").forEach(wrapper => {
      const name = wrapper.id.replace("dock-wrapper-", "");

      const icon = wrapper.querySelector(".dock-icon");
      if (!icon) return;

      icon.addEventListener("click", () => {
        wrapper.classList.add("active");
        openDockApps.add(name);
      });
    });

    // Listen for app close messages
    window.addEventListener("message", (e) => {
      if (e.data.type === "app-closed" && e.data.name) {
        if (openDockApps.has(e.data.name)) {
          openDockApps.delete(e.data.name);
          const wrapper = document.getElementById(`dock-wrapper-${e.data.name}`);
          if (wrapper) wrapper.classList.remove("active");
        }
      }
    });

    // Optional: expose list
    window.getOpenDockApps = () => Array.from(openDockApps);
  }



let fakeFileSystem = {};

function trackRecentFile(path) {
  if (!path || typeof path !== "string") return;

  const user = localStorage.getItem("currentUser") || "admin"; // fallback to admin
  const key = `recentFiles:${user}`; // user-specific key

  let recents = JSON.parse(localStorage.getItem(key) || "[]");
  recents = recents.filter(p => p !== path); // remove duplicate
  recents.push(path);
  if (recents.length > 20) recents.shift(); // keep latest 20 only

  localStorage.setItem(key, JSON.stringify(recents));
}


window.trackRecentFile = trackRecentFile; // üëà Makes it available to File Explorer





  let currentUser = localStorage.getItem("currentUser");




let viewingUser = null; // <== Add this line!

function loadUserFileSystem() {
  const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
  const userFS = allUsers[currentUser] || { "/": [] };
  const adminFS = allUsers["admin"] || { "/": [] };

  let effectiveFS;

  if (currentUser === "admin" && viewingUser) {
    // ‚úÖ Admin is temporarily viewing another user
    const viewedFS = allUsers[viewingUser] || { "/": [] };
    const mergedRoot = Array.from(new Set([...(adminFS["/"] || []), ...(viewedFS["/"] || [])]));
    effectiveFS = { ...adminFS, ...viewedFS, "/": mergedRoot };

  } else if (currentUser === "admin") {
    // ‚úÖ Admin using their own account
    effectiveFS = adminFS;

  } else {
    // ‚úÖ Regular user ‚Äî only their own files
    effectiveFS = userFS;
  }

  // Load into fakeFileSystem
  Object.keys(fakeFileSystem).forEach(k => delete fakeFileSystem[k]); // clear
  Object.entries(effectiveFS).forEach(([k, v]) => {
    fakeFileSystem[k] = v;
  });
}


  function printToTerminal(message) {
    const terminalOutput = document.getElementById("terminal-output");
    if (terminalOutput) {
      const line = document.createElement("div");
      line.textContent = message;
      terminalOutput.appendChild(line);
      terminalOutput.scrollTop = terminalOutput.scrollHeight;
    } else {
      console.log("[Terminal]", message);
    }
  }

  function maximizeWindow(windowEl) {
    windowEl.style.position = 'fixed';
    windowEl.style.width = '100vw';
    windowEl.style.height = '100vh';
    windowEl.style.left = '5vw';
    windowEl.style.top = '3vh';
  }


  function saveUserFileSystem() {
    const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
    allUsers[currentUser] = fakeFileSystem;
    localStorage.setItem("userFileSystems", JSON.stringify(allUsers));
    localStorage.setItem("currentUser", currentUser);
  }

//localStorage.removeItem("fakeFileSystem");

    const terminal = document.getElementById("terminal");
    function getPromptText() {
  const viewing = viewingUser ? `(viewing:${viewingUser})` : "";
  return `${currentUser}${viewing}@Intnix:1.04:${currentDir}$`;
}



    let currentDir = "/";

    // Load filesystem from localStorage, or create default


    const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");

    // Use real file system based on current user
    if (allUsers[currentUser]) {
      fakeFileSystem = structuredClone(allUsers[currentUser]);
    } else {
      // Fallback or first-time setup
      allUsers[currentUser] = { "/": [] };
      fakeFileSystem = { "/": [] };
      localStorage.setItem("userFileSystems", JSON.stringify(allUsers));
    }



    const commands = {};

    function registerCommand(name, fn) {
      commands[name] = fn;
    }


    registerCommand("sudo", args => {
  return (async () => {

    // ---- HTML INSTALL BLOCK ----
    if (args[0] === "html") {
      if (args[1] === "install") {
        const name = args[2]?.replace(/\"/g, "");
        const file = args[3];
        const icon = args[4] || "default.jpg";
        if (!name || !file) {
          return 'Usage: sudo html install "App Name" file.html [icon.jpg]';
        }

        const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
        registry[name] = { file, icon };
        localStorage.setItem("appRegistry", JSON.stringify(registry));

        return `‚úÖ Installed "${name}" from ${file}`;
      }

      if (args[1] === "list") {
        const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
        return Object.keys(registry).length
          ? Object.entries(registry).map(([k, v]) => `‚Ä¢ ${k} -> ${v.file}`).join("\n")
          : "No apps installed.";
      }
    }
    if (args[0] === "apt") {
      return new Promise((resolve) => {
        const fileNameFromArg = args[1];
        if (!fileNameFromArg || !fileNameFromArg.endsWith(".html")) {
          resolve('‚ùå You must specify the exact filename with ".html", e.g., sudo apt example.html');
          return;
        }

        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".html";
        input.style.display = "none";
        document.body.appendChild(input);

        input.onchange = () => {
          const file = input.files[0];
          if (!file) {
            resolve("‚ùå No file selected.");
            return;
          }

          if (file.name !== fileNameFromArg) {
            resolve(`‚ùå Selected file "${file.name}" doesn't match specified filename "${fileNameFromArg}".`);
            return;
          }

          const reader = new FileReader();
          reader.onload = () => {
            let name = prompt("App Name?");
            if (!name || !name.trim()) {
              resolve("‚ùå Installation cancelled. App name is required.");
              return;
            }

            name = name.trim();
            const icon = prompt("Icon file (optional):") || "default.jpg";
            const folder = "/apps";

            const lockedMap = JSON.parse(localStorage.getItem("lockedFolderMap") || "{}");
            const realFolder = lockedMap[folder] || folder;

            const appFileName = file.name.replace(/\.html$/, ".app");
            const virtualPath = `${realFolder}/${appFileName}`;

            // Ensure folder exists
            if (!fakeFileSystem[realFolder]) fakeFileSystem[realFolder] = [];

            // Add .app file to the file system
            if (!fakeFileSystem[realFolder].includes(appFileName)) {
              fakeFileSystem[realFolder].push(appFileName);
            }

            // Save app metadata with apt source tag
            const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
            appMeta[virtualPath] = {
              name,
              icon,
              type: "app",
              content: reader.result,
              source: "apt" // ‚úÖ Tag as apt-installed
            };
            localStorage.setItem("appFileMeta", JSON.stringify(appMeta));

            // Register the app with source tag too
            const registry = JSON.parse(localStorage.getItem("appRegistry") || {});
            registry[name] = {
              file: virtualPath,
              icon,
              source: "apt" // ‚úÖ Tag in registry
            };
            localStorage.setItem("appRegistry", JSON.stringify(registry));

            saveFileSystem();
            resolve(`‚úÖ Installed "${name}" as ${appFileName} in ${realFolder} (source: apt)`);
          };

          reader.readAsText(file);
        };

        input.click();
      });
    }






    // ---- FILE REGISTER (Lightweight - no upload) ----
    if (args[0] === "file") {
      const fileName = args[1];
      const folderName = args[2];

      if (!fileName || !folderName) {
        return '‚ùå Usage: sudo file example.html examplefolder';
      }

      const folderPath = currentDir === "/" ? `/${folderName}` : `${currentDir}/${folderName}`;
      if (!fakeFileSystem[folderPath]) return ` ${folderName}`;

      if (!fakeFileSystem[folderPath].includes(fileName)) {
        fakeFileSystem[folderPath].push(fileName);
        saveFileSystem();
      }

      return `üìù Registered file "${fileName}" in folder "${folderName}" (content not stored)`;
    }

    // ---- FOLDER CREATION ----
    if (args[0] === "folder") {
      const folderName = args[1]?.replace(/\"/g, "");
      if (!folderName) return '‚ùå Usage: sudo folder "FolderName"';
      return createFolder(folderName);
    }

    // ---- APT INSTALL (LOCAL FILE PICKER) ----
    // ---- APT INSTALL (LOCAL FILE PICKER) ----
    registerCommand("assign", args => {
    const fileName = args[0]?.replace(/\"/g, "");
    const option = args[1]?.toLowerCase();
    const value = args[2]?.replace(/\"/g, "");

    if (!fileName || option !== "icon" || !value) {
      return `‚ùå Usage: assign "filename.oos" icon "icon.jpg"`;
    }

    // Search every directory
    let filePath = null;
    for (const dir in fakeFileSystem) {
      if (fakeFileSystem[dir].includes(fileName)) {
        filePath = dir === "/" ? `/${fileName}` : `${dir}/${fileName}`;
        break;
      }
    }

    if (!filePath) {
      return `‚ùå File "${fileName}" not found in any directory.`;
    }

    // Assign metadata to file
    const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
    if (!appMeta[filePath]) {
      appMeta[filePath] = {};
    }

    appMeta[filePath].icon = value;
    appMeta[filePath].type = "app";
    localStorage.setItem("appFileMeta", JSON.stringify(appMeta));

    // üîÑ Optional: register to appRegistry too
    const appName = prompt("Enter app name to register (optional):", fileName.replace(/\..+$/, ""));
    if (appName) {
      const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
      registry[appName] = { file: filePath, icon: value };
      localStorage.setItem("appRegistry", JSON.stringify(registry));
    }

    return `üñºÔ∏è Icon for "${fileName}" set to "${value}" at ${filePath}`;
  });




    // ---- USER CREATION ----
    if (args[0] === "user") {
      const username = args[1];

      if (!username) return "‚ùå Usage: sudo user [username]";

      const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
      if (allUsers[username]) return `‚ùå User "${username}" already exists.`;

      // ‚úÖ Create default folders apps and dock for new users
      allUsers[username] = {
        "/": ["apps", "dock", "desktop"],
        "/apps": [],
        "/desktop": [],
        "/dock": []
      };

      localStorage.setItem("userFileSystems", JSON.stringify(allUsers));
      return `‚úÖ User "${username}" created with default folders.`;
    }

    return 'Unknown sudo command. Try: sudo html install, sudo file, sudo folder, sudo apt, or sudo user';
    })();
    });



function enforceFolderStatus() {
  for (const path in fakeFileSystem) {
    if (Array.isArray(fakeFileSystem[path])) {
      fakeFileSystem[path]._isFolder = true;
    }
  }
}



registerCommand("ls", () => {
const contents = fakeFileSystem[currentDir];
if (!contents) return "‚ùå Directory not found.";

const map = JSON.parse(localStorage.getItem("lockedFolderMap") || "{}");
const maskedMap = {}; // reverse map: encryptedName ‚Üí visibleName
Object.entries(map).forEach(([k, v]) => {
  const encName = v.split("/").pop();
  const visName = k.split("/").pop();
  maskedMap[encName] = visName;
});

return contents
  .map(item => {
    const displayName = maskedMap[item] || item;
    const path = currentDir === "/" ? `/${item}` : `${currentDir}/${item}`;
    return fakeFileSystem[path]?._isFolder
      ? `[DIR] ${displayName}`
      : `     ${displayName}`;
  })
  .join("\n");
});



  registerCommand("cd", args => {
  const target = args[0];
  if (!target) return '‚ùå Usage: cd [folder]';

  let newPath;

  if (target === "..") {
    if (currentDir === "/") return '‚ùå Already at root folder.';
    newPath = currentDir.substring(0, currentDir.lastIndexOf("/")) || "/";
  } else if (target.startsWith("/")) {
    newPath = target;
  } else {
    newPath = currentDir === "/" ? `/${target}` : `${currentDir}/${target}`;
  }

  newPath = newPath.replace(/\/+/g, '/');

  if (fakeFileSystem[newPath]) {
    currentDir = newPath;
    const contents = fakeFileSystem[currentDir];
    return `üìÅ Moved to ${currentDir}\n${contents.join("\n")}`;
  }

  return `‚ùå Folder not found: ${target}`;
});





registerCommand("back", () => {
  if (currentDir === "/") return "‚ùå Already at root.";
  currentDir = currentDir.split("/").slice(0, -1).join("/") || "/";
  const contents = fakeFileSystem[currentDir] || [];
  return `‚¨ÖÔ∏è Back to ${currentDir}\n${contents.join("\n")}`;
});

// Optional alias
registerCommand("up", () => commands["back"]());


let commandHistory = [];
let historyIndex = -1;

function createInputLine() {
  const line = document.createElement("div");
  line.className = "input-container";

  const prompt = document.createElement("span");
  prompt.className = "prompt";
  prompt.textContent = getPromptText();
  prompt.style.color = promptColor;

  const input = document.createElement("input");
  input.className = "cmd-input";
  input.autofocus = true;

  const suggestionBox = document.createElement("div");
  suggestionBox.className = "suggestion-box";
  suggestionBox.style.display = "none";

  line.appendChild(prompt);
  line.appendChild(input);
  line.appendChild(suggestionBox);
  terminal.appendChild(line);
  input.focus();

  let suggestions = [];
  let selectedIndex = -1;

  // üîÅ Restore current session history
  historyIndex = commandHistory.length;

  // üîç Suggestions (autocomplete)
  input.addEventListener("input", () => {
    const value = input.value.trim();
    if (!value) {
      suggestionBox.style.display = "none";
      return;
    }

    suggestions = Object.keys(commands)
      .filter(cmd => cmd.startsWith(value))
      .slice(0, 5);

    if (suggestions.length === 0) {
      suggestionBox.style.display = "none";
      return;
    }

    suggestionBox.innerHTML = '';
    suggestions.forEach((cmd, i) => {
      const div = document.createElement("div");
      div.className = "suggestion";
      div.textContent = cmd;
      div.onclick = () => {
        input.value = cmd + " ";
        suggestionBox.style.display = "none";
        input.focus();
      };
      suggestionBox.appendChild(div);
    });

    suggestionBox.style.display = "block";
    selectedIndex = -1;
  });


  function updateSelectedSuggestion() {
    [...suggestionBox.children].forEach((child, i) => {
      child.classList.toggle('selected', i === selectedIndex);
    });
  }

  input.addEventListener("keydown", function (e) {
    // üü® Command history logic
    if (e.key === "ArrowUp") {
      if (historyIndex > 0) {
        historyIndex--;
        input.value = commandHistory[historyIndex] || "";
        e.preventDefault();
      }
    }

    if (e.key === "ArrowDown") {
      if (historyIndex < commandHistory.length - 1) {
        historyIndex++;
        input.value = commandHistory[historyIndex] || "";
      } else {
        historyIndex = commandHistory.length;
        input.value = "";
      }
      e.preventDefault();
    }

    // üîÅ Autocomplete navigation
    if (suggestionBox.style.display !== "none") {
    if (e.key === "Tab" || e.key === "ArrowDown") {
      e.preventDefault();
      selectedIndex = (selectedIndex + 1) % suggestions.length;
      updateSelectedSuggestion();
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      selectedIndex = (selectedIndex - 1 + suggestions.length) % suggestions.length;
      updateSelectedSuggestion();
    } else if ((e.key === " " || e.code === "Space") && selectedIndex >= 0) {
      e.preventDefault();
      input.value = suggestions[selectedIndex] + " ";
      suggestionBox.style.display = "none";
    } else if (e.key === "Escape") {
      suggestionBox.style.display = "none";
    }
  }


    // üü© Enter command
    if (e.key === "Enter") {
      suggestionBox.style.display = "none";
      const inputVal = input.value.trim();
      if (inputVal) {
        commandHistory.push(inputVal);
        historyIndex = commandHistory.length;
      }
      handleCommand(inputVal);
      input.disabled = true;
      createInputLine();
    }
  });

  terminal.scrollTop = terminal.scrollHeight;
}



  registerCommand("echo", args => {
    return args.join(" ");
  });


  registerCommand("oplus", () => {
    return `üìò O++ Language Syntax Guide:

    O++ is a layout-based GUI definition language designed for visual app building in nebula OS.

   üîπ SYNTAX:
   Each GUI element is defined by a block like:

     mybox {
       type: shape
       x: 100
       y: 200
       shape: circle
       shapecolor: "#00ff88"
       drag: true
     }

   Blocks can now be expanded using variables:

     varicon = 3

     $icon {
       x: auto * 100
       y: 50
       type: shape
       shapecolor: red
     }

     $icon1 {
       shapecolor: blue
       command: "echo clicked"
       interact: true
     }

   This creates icon0, icon1, icon2. icon1 will inherit all base properties and override its color and behavior.

   üîπ COMMON TYPES:
   ‚Ä¢ type: shape ‚Äî a box, circle, pill, or square visual.
   ‚Ä¢ type: text ‚Äî displays a paragraph of content.
   ‚Ä¢ type: input ‚Äî an input field.
   ‚Ä¢ type: button ‚Äî a clickable button.

   üîπ POSITIONING:
   ‚Ä¢ x / y ‚Äî initial position in pixels.
   ‚Ä¢ auto ‚Äî dynamic value based on index when using $variable blocks.
   ‚Ä¢ dragx / dragy ‚Äî updated position after dragging.
   ‚Ä¢ drag: true ‚Äî makes the element draggable.

   üîπ COLORS:
   ‚Ä¢ textcolor ‚Äî changes text color.
   ‚Ä¢ shapecolor ‚Äî changes background for shapes.
   ‚Ä¢ buttoncolor ‚Äî sets button background.

   üîπ BUTTON BEHAVIOR:
   ‚Ä¢ label: "Click me" ‚Äî sets button label.
   ‚Ä¢ command: "echo hello" ‚Äî runs terminal command on click.
   ‚Ä¢ inputbind: name ‚Äî replaces INPUT in the command with bound input value.

   üîπ INTERACT FIELD:
   ‚Ä¢ interact: true ‚Äî makes any object clickable.
   ‚Ä¢ command: "..." ‚Äî triggered when clicked.
   ‚Ä¢ drag: true ‚Äî allows user to drag an object.
   ‚Ä¢ drop: true ‚Äî allows object to trigger command when dropped on a target.
   ‚Ä¢ target: true ‚Äî marks an object as a valid drop target.

   üîπ EXAMPLES:
     coolbtn {
       type: button
       x: 120
       y: 300
       label: "Run"
       command: "run hello.html"
     }

     greeting {
       type: text
       x: 100
       y: 100
       content: "Welcome!"
     }

     varcircle = 3

     $circle {
       x: auto * 80
       y: 150
       type: shape
       shape: circle
       shapecolor: red
     }

     $circle1 {
       shapecolor: green
       interact: true
       command: "echo I am green"
     }

  Use \`generatefile example\` to create a starter file.
  Use \`link example.oos = "command"\` to assign it behavior.`;
  });




  async function handleCommand(raw, retry = true) {
    const output = document.createElement("div");
    const [cmd, ...args] = raw.trim().split(" ");
    const fn = commands[cmd];

    const commandsToTrack = ["launch", "runlink", "nano"];
    if (commandsToTrack.includes(cmd)) {
      const argPath = args[0]?.replace(/\"/g, "");
      if (argPath) {
        const fullPath = argPath.startsWith("/") ? argPath : `${currentDir}/${argPath}`;
        trackRecentFile(fullPath.replace(/\/+/g, "/"));
      }
    }

    if (fn) {
      const result = await Promise.resolve(fn(args));
      output.textContent = result;
    } else if (retry) {
      // üîÅ Wait 250ms and retry once
      setTimeout(() => handleCommand(raw, false), 250);
      return;
    } else {
      // üîç Optional fuzzy match
      const possibleMatches = Object.keys(commands).filter(k => k.startsWith(cmd));
      if (possibleMatches.length === 1) {
        const result = await Promise.resolve(commands[possibleMatches[0]](args));
        output.textContent = result + ` (interpreted as "${possibleMatches[0]}")`;
      } else {
        output.textContent = `‚ùå Command not found: ${cmd}`;
      }
    }

    terminal.appendChild(output);
  }


  async function executeCommand(raw, retry = true) {
    const output = document.createElement("div");
    const input = raw.trim();
    let matchedCommand = null;
    let matchedArgs = [];

    // Try to match longest command name first
    const sortedCommands = Object.keys(commands).sort((a, b) => b.length - a.length);

    for (const name of sortedCommands) {
      if (input.startsWith(name)) {
        matchedCommand = name;
        const remaining = input.slice(name.length).trim();
        matchedArgs = remaining ? remaining.split(" ") : [];
        break;
      }
    }

    // Track recent files
    const commandsToTrack = ["launch", "runlink", "nano"];
    if (matchedCommand && commandsToTrack.includes(matchedCommand)) {
      const argPath = matchedArgs[0]?.replace(/\"/g, "");
      if (argPath) {
        const fullPath = argPath.startsWith("/") ? argPath : `${currentDir}/${argPath}`;
        trackRecentFile(fullPath.replace(/\/+/g, "/"));
      }
    }

    if (matchedCommand && commands[matchedCommand]) {
      const result = await Promise.resolve(commands[matchedCommand](matchedArgs));
      output.textContent = result;
    } else if (retry) {
      // Retry once after slight delay
      return setTimeout(() => executeCommand(raw, false), 250);
    } else {
      output.textContent = `‚ùå Command not found: "${raw}"`;
    }

    terminal.appendChild(output);
  }



    createInputLine();
    registerCommand("neofetch", () => {
    // Launch the animated donut
    handleCommand("donut");

    const currentUser = localStorage.getItem("currentUser") || "admin";
    const viewingUser = window.viewingUser || null;

    const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
    const passwords = JSON.parse(localStorage.getItem("userPasswords") || "{}");
    const bg = localStorage.getItem(`desktopBackground:${currentUser}`) || "Not Set";

    const recents = JSON.parse(localStorage.getItem(`recentFiles:${currentUser}`) || "[]");
    const appRegistry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
    const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");

    const dockItems = Object.keys(appMeta).filter(path => path.startsWith("/dock/"));
    const userFS = allUsers[currentUser] || {};

    let fileCount = 0;
    let folderCount = 0;
    let htmlCount = 0;
    let oosCount = 0;
    let iconCount = 0;

    for (const [path, items] of Object.entries(userFS)) {
      if (Array.isArray(items)) {
        folderCount++;
        fileCount += items.length;

        items.forEach(file => {
          if (file.endsWith(".html")) htmlCount++;
          if (file.endsWith(".oos")) oosCount++;

          const fullPath = path === "/" ? `/${file}` : `${path}/${file}`;
          if (appMeta[fullPath]?.icon) iconCount++;
        });
      }
    }

    let totalUsed = 0;
    for (let key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        try {
          const value = localStorage.getItem(key);
          totalUsed += key.length + value.length;
        } catch {}
      }
    }

    const totalQuota = 5 * 1024 * 1024; // 5MB
    const percentUsed = ((totalUsed / totalQuota) * 100).toFixed(2);
    const usedKB = (totalUsed / 1024).toFixed(1);
    const quotaKB = (totalQuota / 1024).toFixed(0);

    const info = [
      `üë§ User              : ${currentUser}`,
      `üîê Password Set      : ${passwords[currentUser] ? "Yes" : "No"}`,
      `üëÅÔ∏è Access Mode       : ${viewingUser ? `Viewing ${viewingUser}` : "Normal"}`,
      `üë• Total Users       : ${Object.keys(allUsers).length}`,
      `üñºÔ∏è  Background Image : ${bg}`,
      `üóÇÔ∏è  Folders           : ${folderCount}`,
      `üìÑ Files             : ${fileCount}`,
      `  ‚î£ üìú .html Files    : ${htmlCount}`,
      `  ‚îó üîó .oos Files     : ${oosCount}`,
      `üñºÔ∏è  Icon Assignments : ${iconCount}`,
      `üì¶ Installed Apps    : ${Object.keys(appRegistry).length}`,
      `üß† Recent Files      : ${recents.length}`,
      `üß≤ Dock Items        : ${dockItems.length}`,
      `üíæ Storage Used      : ${usedKB} KB / ${quotaKB} KB (${percentUsed}%)`,
      `üñ•Ô∏è Platform           : ${navigator.platform}`,
      `üåê User Agent        : ${navigator.userAgent.split(" ")[0]}`,
      `üìç Current Directory : ${currentDir}`,
      `üïì Time              : ${new Date().toLocaleTimeString()}`
    ];

    // Return info text to appear below donut
    return `\n${info.join("\n")}`;
  });




  const aliases = {};

  function handleCommand(raw) {
    const output = document.createElement("div");

    // Handle alias definition directly
    if (raw.startsWith('alias ')) {
      const aliasParts = raw.substring(6).split('=');
      const aliasName = aliasParts[0]?.trim();
      const commandString = aliasParts.slice(1).join('=').replace(/^["']|["']$/g, '').trim();

      if (!aliasName || !commandString) {
        output.textContent = "Usage: alias name='command args'";
      } else {
        aliases[aliasName] = commandString;
        output.textContent = `‚úÖ Alias added: ${aliasName}='${commandString}'`;
      }

      terminal.appendChild(output);
      return;
    }

    let [cmd, ...args] = raw.split(" ");

    // Check and expand alias
    if (aliases[cmd]) {
      const expanded = aliases[cmd].split(" ");
      cmd = expanded[0];
      args = [...expanded.slice(1), ...args];
    }

    const fn = commands[cmd];

    if (fn) {
      Promise.resolve(fn(args)).then(result => {
        output.textContent = result;
      });
    } else {
      output.textContent = `Command not found: ${cmd}`;
    }

    terminal.appendChild(output);
  }
  // Update your fakeFileSystem object
  // Saving the filesystem state to localStorage
  function saveFileSystem() {
  const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");

  const targetUser = (currentUser === "admin" && viewingUser) ? viewingUser : currentUser;

  allUsers[targetUser] = structuredClone(fakeFileSystem);
  localStorage.setItem("userFileSystems", JSON.stringify(allUsers));
}



  // Creating folders persistently
  function createFolder(folderName) {
    const path = currentDir.endsWith("/") ? currentDir + folderName : currentDir + "/" + folderName;
    if (!fakeFileSystem[path]) {
      fakeFileSystem[path] = [];
      fakeFileSystem[currentDir].push(folderName);
      saveFileSystem(); // <-- persist to localStorage

      // ‚úÖ NEW: Save backup to .json
      const blob = new Blob([JSON.stringify(fakeFileSystem, null, 2)], { type: "application/json" });
      saveAs(blob, "filesystem_backup.json");

      return `üìÅ Folder created: ${folderName}`;
    }
    return `‚ùå Folder already exists: ${folderName}`;
  }



  registerCommand("user", args => {
    if (args[0] === "apps") {
      const registry = JSON.parse(localStorage.getItem("appRegistry") || {});
      const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});

      if (!Object.keys(registry).length) {
        return 'üìÇ No apps installed.';
      }

      const userApps = [];

      for (const [name, details] of Object.entries(registry)) {
        const path = details.file;
        const meta = appMeta[path] || {};
        const isApt = details.source === "apt" || meta.source === "apt";

        if (isApt) {
          const entry = `üî∏ ${name} ‚ûú ${details.file}`;
          userApps.push(entry);
        }
      }

      return userApps.length
        ? `üë§ User Apps:\n${userApps.join("\n")}`
        : "üìÇ No user-installed apps (apt) found.";
    }

    return 'Usage: view apps';
  });



  registerCommand("amend", args => {
    const folderName = args[0]?.replace(/\"/g, "");
    const fileName = args[1]?.replace(/\"/g, "");
    if (!folderName || !fileName) return '‚ùå Usage: amend "FolderName" "file.html"';

    const folderPath = currentDir === '/' ? `/${folderName}` : `${currentDir}/${folderName}`;

    if (fakeFileSystem[folderPath]) {
      fakeFileSystem[folderPath].push(fileName);
      localStorage.setItem("fakeFileSystem", JSON.stringify(fakeFileSystem));
      return `üìÑ Added file "${fileName}" to folder "${folderName}"`;
    }
    return `‚ùå Folder does not exist: ${folderName}`;
  });

  registerCommand("zip", async args => {
    const folderName = args[0]?.replace(/\"/g, "");
    const zipName = args[1]?.replace(/\"/g, "") || `${folderName}.zip`;

    if (!folderName) return '‚ùå Usage: zip "FolderName" "ZipName"';

    const folderPath = currentDir.endsWith("/") ? currentDir + folderName : currentDir + "/" + folderName;
    if (!fakeFileSystem[folderPath]) {
      return `‚ùå Folder "${folderName}" does not exist`;
    }

    const zip = new JSZip();
    const files = fakeFileSystem[folderPath];

    files.forEach(file => {
      // For simplicity, files contain dummy content.
      zip.file(file, `Contents of ${file}`);
    });

    try {
      const content = await zip.generateAsync({ type: "blob" });
      saveAs(content, zipName.endsWith('.zip') ? zipName : `${zipName}.zip`);
      return `üì¶ Created and downloaded ${zipName}`;
    } catch (err) {
      return `‚ùå Error creating zip: ${err.message}`;
    }
  });

  registerCommand("rm", args => {
    const input = args[0]?.replace(/\"/g, "");
    if (!input) return '‚ùå Usage: rm [fileOrFolderName or /path/to/item]';

    const protectedFolders = ["apps", "dock", "desktop"];

    // Determine full path
    const fullPath = input.startsWith("/") ? input : `${currentDir}/${input}`;
    const cleanPath = fullPath.replace(/\/+/g, "/");

    const segments = cleanPath.split("/").filter(Boolean);
    const targetName = segments.pop();
    const parentPath = "/" + segments.join("/");

    // Check if protected
    if (protectedFolders.includes(targetName)) {
      const allPasswords = JSON.parse(localStorage.getItem("userPasswords") || "{}");
      const expectedPassword = allPasswords[currentUser];

      if (!expectedPassword) {
        return "‚ùå You must set a user password before deleting protected folders.";
      }

      const password = prompt(`‚ö†Ô∏è Protected folder! Please enter your password to confirm deletion of "${targetName}":`);
      if (password !== expectedPassword) {
        return "‚ùå Incorrect password. Deletion cancelled.";
      }
    }

    // Delete folder
    if (fakeFileSystem[cleanPath]) {
      delete fakeFileSystem[cleanPath];
      if (fakeFileSystem[parentPath]) {
        fakeFileSystem[parentPath] = fakeFileSystem[parentPath].filter(item => item !== targetName);
      }
      saveFileSystem();
      return `üóëÔ∏è Folder "${targetName}" deleted.`;
    }

    // Delete file
    if (fakeFileSystem[parentPath]?.includes(targetName)) {
      fakeFileSystem[parentPath] = fakeFileSystem[parentPath].filter(item => item !== targetName);
      saveFileSystem();
      localStorage.removeItem("fileContent:" + cleanPath);
      return `üóëÔ∏è File "${targetName}" deleted.`;
    }

    return `‚ùå "${input}" not found.`;
  });


  // Persist initial filesystem
  if (!localStorage.getItem("fakeFileSystem")) {
  localStorage.setItem("fakeFileSystem", JSON.stringify(fakeFileSystem));
}


  // Function to delete an installed app from appRegistry
  function deleteApp(appName) {
    const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
    const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
    const appInfo = registry[appName];

    if (!appInfo) return `‚ùå App "${appName}" not found in registry.`;

    const appPath = appInfo.file; // e.g., /apps/example.html
    const segments = appPath.split("/");
    const fileName = segments.pop();
    const folderPath = segments.join("/") || "/";

    // 1. Remove from /apps folder
    if (fakeFileSystem[folderPath]) {
      fakeFileSystem[folderPath] = fakeFileSystem[folderPath].filter(f => f !== fileName);
    }

    // 2. Remove metadata
    delete appMeta[appPath];

    // 3. Remove file content
    localStorage.removeItem("fileContent:" + appPath);

    // 4. Remove from registry
    delete registry[appName];

    // 5. Save everything back
    localStorage.setItem("appRegistry", JSON.stringify(registry));
    localStorage.setItem("appFileMeta", JSON.stringify(appMeta));
    saveFileSystem();

    return `üóëÔ∏è App "${appName}" and its file "${fileName}" have been deleted.`;
  }

  registerCommand("deleteapp", args => {
    const input = args.join(" ").replace(/\"/g, "").trim();
    if (!input) return '‚ùå Usage: deleteapp "App Name" or deleteapp /apps/filename.html';

    const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
    const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});

    // 1. Try exact app name match
    if (registry[input]) {
      return deleteApp(input); // Use the full deleteApp function above
    }

    // 2. Try to find by file name or path
    let foundAppName = null;
    for (const [name, { file }] of Object.entries(registry)) {
      if (file === input || file.endsWith("/" + input)) {
        foundAppName = name;
        break;
      }
    }

    if (foundAppName) {
      return deleteApp(foundAppName);
    }

    return `‚ùå App "${input}" not found in registry.`;
  });

  registerCommand("amendapp", args => {
executeCommand("refresh");
    const appName = args[0]?.replace(/\"/g, "");
    const folderName = args[1]?.replace(/\"/g, "");

    if (!appName || !folderName) {
      return '‚ùå Usage: amendapp "AppName" "FolderName"';
    }

    const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
    const appDetails = registry[appName];

    if (!appDetails) {
      return `‚ùå App "${appName}" not found in registry.`;
    }

    const folderPath = currentDir === '/' ? `/${folderName}` : `${currentDir}/${folderName}`;
    if (!fakeFileSystem[folderPath]) {
      return `‚ùå Folder "${folderName}" does not exist.`;
    }

    const appFileName = appName.endsWith(".app") ? appName : `${appName}.app`;
    const newAppPath = `${folderPath}/${appFileName}`;
    const originalFilePath = appDetails.file;

    // Add file to directory if missing
    if (!fakeFileSystem[folderPath].includes(appFileName)) {
      fakeFileSystem[folderPath].push(appFileName);
    }

    // Store metadata
    const appFileMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
    appFileMeta[newAppPath] = {
      name: appName,
      file: originalFilePath,
      icon: appDetails.icon,
      type: "app"
    };
    localStorage.setItem("appFileMeta", JSON.stringify(appFileMeta));

    // üìù Copy actual file content into the .app wrapper
    const content = localStorage.getItem("fileContent:" + originalFilePath);
    if (content !== null) {
      localStorage.setItem("fileContent:" + newAppPath, content);
    }

    saveFileSystem();
    return `üì¶ App "${appName}" saved in folder "${folderName}" as "${appFileName}" with content.`;
  });



  registerCommand("pwd", () => currentDir);


  registerCommand("nano", args => {
    let inputPath = args[0] || null;
    let fileName = null;
    let filePath = null;

    if (inputPath?.startsWith("/")) {
      filePath = inputPath;
      fileName = inputPath.split("/").pop();
    } else if (inputPath) {
      fileName = inputPath;
      filePath = currentDir === "/" ? `/${fileName}` : `${currentDir}/${fileName}`;
    }

    // Ensure parent folder and file are created BEFORE opening editor
    if (filePath && fileName) {
      const folderPath = filePath.substring(0, filePath.lastIndexOf("/")) || "/";
      const folderName = folderPath === "/" ? "/" : folderPath.split("/").pop();

      // Create parent folders if missing
      if (!fakeFileSystem[folderPath]) {
        fakeFileSystem[folderPath] = [];

        const segments = folderPath.split("/").filter(Boolean);
        if (segments.length > 0) {
          const parentPath = "/" + segments.slice(0, -1).join("/");
          const currentFolder = segments[segments.length - 1];
          if (!fakeFileSystem[parentPath]) fakeFileSystem[parentPath] = [];
          if (!fakeFileSystem[parentPath].includes(currentFolder)) {
            fakeFileSystem[parentPath].push(currentFolder);
          }
        } else if (!fakeFileSystem["/"].includes(folderName)) {
          fakeFileSystem["/"].push(folderName);
        }
      }

      // Add file to folder if missing
      if (!fakeFileSystem[folderPath].includes(fileName)) {
        fakeFileSystem[folderPath].push(fileName);
      }

      // Register the file using `sudo file`
      handleCommand(`sudo file "${fileName}" "${folderName === "/" ? "/" : folderName}"`);

      // Save empty file if new
      if (localStorage.getItem("fileContent:" + filePath) === null) {
        localStorage.setItem("fileContent:" + filePath, "");
      }

      saveFileSystem();
    }

    // Load content
    const savedContent = filePath
      ? localStorage.getItem("fileContent:" + filePath) || ""
      : "";

    // === UI Stuff ===
    const container = document.createElement("div");
    container.style.border = "1px solid #00ff88";
    container.style.marginTop = "10px";
    container.style.backgroundColor = "#000";
    container.style.fontFamily = "monospace";

    const header = document.createElement("div");
    header.textContent = `  GNU nano 7.0                             ${fileName || "[New File]"}`;
    header.style.backgroundColor = "#222";
    header.style.color = "#00ff88";
    header.style.padding = "4px";

    const editor = document.createElement("textarea");
    editor.style.width = "100%";
    editor.style.height = "300px";
    editor.style.backgroundColor = "#000";
    editor.style.color = "#00ff88";
    editor.style.border = "none";
    editor.style.resize = "none";
    editor.style.outline = "none";
    editor.style.padding = "10px";
    editor.style.boxSizing = "border-box";
    editor.value = savedContent;

    const footer = document.createElement("div");
    footer.innerHTML = `
      <div style="color:#00ff88; background:#222; padding:4px; font-size:14px;">
        ^G Help   ^O Write Out   ^X Exit   ^K Cut   ^U Paste
      </div>`;

    editor.addEventListener("keydown", e => {
      if (e.ctrlKey && e.key.toLowerCase() === "o") {
        e.preventDefault();

        if (!fileName) {
          fileName = prompt("File name to write:");
          if (!fileName) return;
          filePath = currentDir === "/" ? `/${fileName}` : `${currentDir}/${fileName}`;
          header.textContent = `  GNU nano 7.0                             ${fileName}`;
        }

        localStorage.setItem("fileContent:" + filePath, editor.value);
        saveFileSystem();
      }

      if (e.ctrlKey && e.key.toLowerCase() === "x") {
        e.preventDefault();
        terminal.removeChild(container);
        createInputLine();
      }
    });

    container.appendChild(header);
    container.appendChild(editor);
    container.appendChild(footer);
    terminal.appendChild(container);
    terminal.scrollTop = terminal.scrollHeight;
    editor.focus();
  });


registerCommand("cat", args => {
  if (!args.length) return "‚ùå Usage: cat [filename]";

  return args.map(fileName => {
    const filePath = currentDir === "/" ? `/${fileName}` : `${currentDir}/${fileName}`;
    const content = localStorage.getItem("fileContent:" + filePath);

    if (content === null) {
      return `‚ùå File not found: ${fileName}`;
    }

    return `üìÑ ${fileName}:\n${content}`;
  }).join("\n\n");
});

registerCommand("touch", args => {
  const fileName = args[0];
  if (!fileName) return "‚ùå Usage: touch [filename]";

  const filePath = currentDir === "/" ? `/${fileName}` : `${currentDir}/${fileName}`;

  // Create in directory
  if (!fakeFileSystem[currentDir].includes(fileName)) {
    fakeFileSystem[currentDir].push(fileName);
    saveFileSystem();
  }

  // Create empty content if it doesn't exist
  if (localStorage.getItem("fileContent:" + filePath) === null) {
    localStorage.setItem("fileContent:" + filePath, "");
  }

  return `üìÑ File created: ${fileName}`;
});


registerCommand("colordir", args => {
  const color = args[0];
  if (!color) return "‚ùå Usage: colordir [color]";

  promptColor = color;
  return `üé® Prompt color changed to ${color}`;
});

let zIndexCounter = 100;
let windowIdCounter = 0;
const openWindows = {}; // Optional: track windows by ID
const minimizedWindows = {};

function createWindow(filePath = null) {
  const win = document.createElement("div");

  let windowId;
  if (filePath) {
    const fileName = filePath.split("/").pop().replace(/\W+/g, "_");
    windowId = `win_${fileName}`;
  } else {
    windowId = "win_" + windowIdCounter++;
  }

  win.id = windowId;
  win.className = "window";
  win.style.zIndex = zIndexCounter++;
  win.style.position = "absolute";
  win.style.left = "100px";
  win.style.top = "100px";
  win.style.width = "800px";
  win.style.height = "600px";
  win.style.resize = "both";
  win.style.overflow = "hidden";
  win.style.minWidth = "200px";
  win.style.minHeight = "150px";

  // üçé Apple-style
  win.style.borderRadius = "14px";
  win.style.border = "1px solid rgba(255,255,255,0.08)";
  win.style.background = "rgba(255,255,255,0.05)";
  win.style.backdropFilter = "blur(25px)";
  win.style.boxShadow = "0 20px 40px rgba(0,0,0,0.4)";

  const titleBar = document.createElement("div");
  titleBar.className = "title-bar";
  titleBar.style.height = "32px";
  titleBar.style.padding = "6px 12px";
  titleBar.style.display = "flex";
  titleBar.style.alignItems = "center";
  titleBar.style.justifyContent = "space-between";
  titleBar.style.background = "rgba(255,255,255,0.08)";
  titleBar.style.backdropFilter = "blur(10px)";
  titleBar.style.borderBottom = "1px solid rgba(255,255,255,0.06)";
  titleBar.style.color = "#fff";
  titleBar.style.fontSize = "14px";
  titleBar.style.fontWeight = "500";

  let appName = "Window";
  if (filePath) {
    const meta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
    const entry = meta[filePath];
    if (entry?.name) {
      appName = entry.name;
    } else {
      appName = filePath.split("/").pop();
    }
  }

  const titleText = document.createElement("span");
  titleText.textContent = appName;
  titleText.style.flex = "1";
  titleText.style.textAlign = "center";

  const controls = document.createElement("div");
  controls.style.display = "flex";
  controls.style.gap = "8px";

  const btn = (color, title, symbol) => {
    const b = document.createElement("button");
    b.title = title;
    b.textContent = symbol;
    b.style.width = "14px";
    b.style.height = "14px";
    b.style.borderRadius = "50%";
    b.style.border = "none";
    b.style.background = color;
    b.style.fontSize = "10px";
    b.style.color = "#00000090";
    b.style.display = "flex";
    b.style.alignItems = "center";
    b.style.justifyContent = "center";
    b.style.cursor = "pointer";
    return b;
  };

  const close = btn("#ff5f56", "Close", "√ó");
  const min = btn("#ffbd2e", "Minimize", "‚Äì");
  const max = btn("#27c93f", "Maximize", "+");

  controls.appendChild(close);
  controls.appendChild(min);
  controls.appendChild(max);

  titleBar.appendChild(controls);
  titleBar.appendChild(titleText);
  titleBar.appendChild(document.createElement("div")); // filler to center

  win.appendChild(titleBar);

  const iframe = document.createElement("iframe");
  iframe.className = "window-content";
  iframe.id = `${windowId}-content`;
  iframe.style.width = "100%";
  iframe.style.height = "100%";
  iframe.style.border = "none";
  iframe.style.backgroundColor = "#1e1e1e";
  iframe.setAttribute("sandbox", "allow-scripts allow-same-origin allow-downloads");

  if (filePath) {
    iframe.setAttribute("data-path", filePath);
    const fileName = filePath.split("/").pop();
    const timestamp = new Date().toISOString();
    windowTracker.push({ id: windowId, name: fileName, path: filePath, time: timestamp });
    localStorage.setItem("windowTracker", JSON.stringify(windowTracker));
    if (typeof trackRecentFile === "function") trackRecentFile(filePath);
  }

  win.appendChild(iframe);
  document.body.appendChild(win);
  openWindows[windowId] = win;

  if (!document.getElementById("taskbar")) {
    const taskbar = document.createElement("div");
    taskbar.id = "taskbar";
    taskbar.style.position = "fixed";
    taskbar.style.top = "0px";
    taskbar.style.left = "0";
    taskbar.style.width = "100%";
    taskbar.style.height = "20px";
    taskbar.style.background = "#2e2e2e";
    taskbar.style.borderTop = "1px solid #111";
    taskbar.style.display = "flex";
    taskbar.style.alignItems = "center";
    taskbar.style.padding = "0 5px";
    taskbar.style.zIndex = "9999";
    taskbar.style.overflowX = "auto";
    document.body.appendChild(taskbar);
  }

  if (!filePath?.includes("file-explorer.html")) {
    const taskBtn = document.createElement("button");
    taskBtn.textContent = appName;
    taskBtn.id = `taskbar-btn-${windowId}`;
    taskBtn.style.margin = "0 4px";
    taskBtn.style.padding = "1px 10px";
    taskBtn.style.background = "#444";
    taskBtn.style.color = "#fff";
    taskBtn.style.border = "0px solid #000";
    taskBtn.style.borderRadius = "3px";
    taskBtn.style.cursor = "pointer";

    taskBtn.onclick = () => {
      if (win.style.display === "none") {
        win.style.display = "block";
        win.style.zIndex = zIndexCounter++;
      } else {
        win.style.display = "none";
      }
    };

    document.getElementById("taskbar").appendChild(taskBtn);
  }

  // Dragging
  let isDragging = false, offsetX = 0, offsetY = 0;
  titleBar.addEventListener("mousedown", e => {
    isDragging = true;
    offsetX = e.clientX - win.offsetLeft;
    offsetY = e.clientY - win.offsetTop;
    win.style.zIndex = zIndexCounter++;
  });

  document.addEventListener("mousemove", e => {
    if (isDragging) {
      win.style.left = `${e.clientX - offsetX}px`;
      win.style.top = `${e.clientY - offsetY}px`;
    }
  });

  document.addEventListener("mouseup", () => isDragging = false);

  // Controls
  close.onclick = () => {
    win.remove();
    const taskBtn = document.getElementById(`taskbar-btn-${windowId}`);
    if (taskBtn) taskBtn.remove();
    delete openWindows[windowId];
  };

  min.onclick = () => {
    win.style.display = "none";
    minimizedWindows[windowId] = win;
  };

  let isMaximized = false;
  let prevStyles = {};

  max.onclick = () => {
    if (!isMaximized) {
      prevStyles = {
        left: win.style.left,
        top: win.style.top,
        width: win.style.width,
        height: win.style.height,
      };
      win.style.position = "fixed";
      win.style.left = "0vw";
      win.style.top = "3vh";
      win.style.width = "100%";
      win.style.height = "90%";
      isMaximized = true;
    } else {
      win.style.position = "absolute";
      win.style.left = prevStyles.left;
      win.style.top = prevStyles.top;
      win.style.width = prevStyles.width;
      win.style.height = prevStyles.height;
      isMaximized = false;
    }
  };

  return windowId;
}


function addMinimizedToDock(windowId, filePath) {
  const dock = document.getElementById("dock");

  // Avoid duplicate dock icons
  if (document.getElementById(`dock-min-${windowId}`)) return;

  const meta = JSON.parse(localStorage.getItem("appFileMeta") || "{}")[filePath] || {};
  const icon = meta.icon || "default.jpg";
  const name = meta.name || filePath.split("/").pop();

  const img = document.createElement("img");
  img.src = icon;
  img.title = name;
  img.className = "dock-icon";
  img.id = `dock-min-${windowId}`;

  img.onclick = () => {
    returnmin([windowId]); // You may need to expose this as a global function
    img.remove(); // Remove dock icon after restore
  };

  dock.appendChild(img);
}


registerCommand("openwin", () => {
  const id = createWindow();
  return `ü™ü Created window ${id}`;
});

registerCommand("run", args => {
  const file = args[0];
  if (!file) return '‚ùå Usage: open file.html';

  // Open the file in a new tab
  window.open(file, "_blank");
  return `üìÇ Preparing to Run "${file}"...`;
});


registerCommand("view", args => {
  if (args[0] === "users") {
    const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
    const userList = Object.keys(allUsers);

    if (!userList.length) return "‚ùå No users found.";
    return `üë• Users:\n‚Ä¢ ${userList.join("\n‚Ä¢ ")}`;
  }

  // existing: view apps
  if (args[0] === "apps") {
    const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");

    if (!Object.keys(registry).length) {
      return 'üìÇ No apps installed.';
    }

    return Object.entries(registry).map(([name, details]) => {
      return `üî∏ App Name: ${name}\nüñºÔ∏è Icon: ${details.icon}\nüìÑ File: ${details.file}`;
    }).join("\n\n");
  }

  return 'Usage: view apps OR view users';
});
registerCommand("deleteuser", args => {
  const username = args[0];
  if (!username) return "‚ùå Usage: deleteuser [username]";
  if (currentUser !== "admin") return "‚ùå Only admin can delete users.";
  if (username === "admin") return "‚ùå You cannot delete the admin account.";

  const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
  const allPasswords = JSON.parse(localStorage.getItem("userPasswords") || "{}");
  const allIcons = JSON.parse(localStorage.getItem("userIcons") || {});

  if (!allUsers[username]) {
    return `‚ùå User "${username}" does not exist.`;
  }

  // Delete user data
  delete allUsers[username];
  delete allPasswords[username];
  delete allIcons[username];

  localStorage.removeItem(`recentFiles:${username}`);
  localStorage.removeItem(`desktopBackground:${username}`);

  // Save updates
  localStorage.setItem("userFileSystems", JSON.stringify(allUsers));
  localStorage.setItem("userPasswords", JSON.stringify(allPasswords));
  localStorage.setItem("userIcons", JSON.stringify(allIcons));

  return `üóëÔ∏è User "${username}" and all associated data have been deleted.`;
});


registerCommand("signin", args => {
  const username = args[0];
  const providedPassword = args[1]?.replace(/\"/g, "");

  if (!username) return "‚ùå Usage: signin username \"password\"";

  const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
  const allPasswords = JSON.parse(localStorage.getItem("userPasswords") || "{}");

  if (!allUsers[username]) {
    return `‚ùå User "${username}" does not exist.`;
  }

  const expectedPassword = allPasswords[username];

  // üîê No password required
  if (!expectedPassword) {
    return completeSignIn(username);
  }

  // üü¢ Password provided inline
  if (providedPassword) {
    if (providedPassword === expectedPassword) {
      return completeSignIn(username);
    } else {
      return "‚ùå Incorrect password.";
    }
  }

  // üïµÔ∏è Otherwise, prompt for password
  const line = document.createElement("div");
  line.className = "input-line";

  const prompt = document.createElement("span");
  prompt.className = "prompt";
  prompt.textContent = "Password: ";
  prompt.style.color = "#00ff88";

  const input = document.createElement("input");
  input.className = "cmd-input";
  input.type = "password";
  input.autofocus = true;
  input.style.letterSpacing = "2px";
  input.style.color = "#00ff88";

  line.appendChild(prompt);
  line.appendChild(input);
  terminal.appendChild(line);
  input.focus();

  input.addEventListener("keydown", function (e) {
    if (e.key === "Enter") {
      const entered = input.value;
      input.disabled = true;

      const output = document.createElement("div");

      if (entered === expectedPassword) {
        output.textContent = `‚úÖ Signed in as "${username}"`;
        terminal.appendChild(output);
        completeSignIn(username);
      } else {
        output.textContent = "‚ùå Incorrect password.";
        terminal.appendChild(output);
      }


    }
  });

  terminal.scrollTop = terminal.scrollHeight;
  return "";
});


function completeSignIn(username) {
  const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");

  allUsers[currentUser] = structuredClone(fakeFileSystem);
  localStorage.setItem("userFileSystems", JSON.stringify(allUsers));

  currentUser = username;
  localStorage.setItem("currentUser", currentUser);
  viewingUser = null;

  fakeFileSystem = {};
  const newFS = allUsers[username] || { "/": [] };
  Object.entries(newFS).forEach(([k, v]) => fakeFileSystem[k] = v);

  currentDir = "/";
  return `‚úÖ Signed in as "${username}"`;
}


registerCommand("signout", () => {
  // Create confirmation popup
  const overlay = document.createElement("div");
  overlay.style = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center;
    z-index: 9999;
  `;

  const popup = document.createElement("div");
  popup.style = `
    background: #1e1e1e; padding: 25px 30px; border-radius: 15px;
    font-family: sans-serif; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    max-width: 300px; text-align: center; color: white;
  `;
  popup.innerHTML = `
    <p style="margin: 0; font-size: 16px;">Are you sure you want to sign out?</p>
    <div style="margin-top: 20px;">
      <button id="cancelSignout" style="
        background: #444; color: white; border: none; padding: 8px 16px;
        border-radius: 8px; margin-right: 10px; cursor: pointer;
      ">Cancel</button>
      <button id="confirmSignout" style="
        background: #007aff; color: white; border: none; padding: 8px 16px;
        border-radius: 8px; cursor: pointer;
      ">Sign Out</button>
    </div>
  `;

  overlay.appendChild(popup);
  document.body.appendChild(overlay);

  // Button actions
  document.getElementById("cancelSignout").onclick = () => {
    document.body.removeChild(overlay);
  };

  document.getElementById("confirmSignout").onclick = () => {
    const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
    allUsers[currentUser] = fakeFileSystem;
    localStorage.setItem("userFileSystems", JSON.stringify(allUsers));

    localStorage.removeItem("currentUser");
    currentUser = null;
    Object.keys(fakeFileSystem).forEach(key => delete fakeFileSystem[key]);
    currentDir = "/";
    window.location.href = "Loginscreen.html";
  };

  return ""; // no terminal output
});


registerCommand("cleardata", () => {
  const confirm1 = confirm("‚ö†Ô∏è This will DELETE ALL USERS, FILES, and SETTINGS. Are you sure?");
  if (!confirm1) return "‚ùå Operation cancelled.";

  const confirm2 = confirm("‚ö†Ô∏è Are you REALLY sure? This cannot be undone.");
  if (!confirm2) return "‚ùå Wipe aborted.";

  // Mark for login screen not to create anything on reload
  localStorage.setItem("justWiped", "true");

  // Specifically remove critical entries
  localStorage.removeItem("userFileSystems");
  localStorage.removeItem("userPasswords");
  localStorage.removeItem("userIcons");
  localStorage.removeItem("appRegistry");
  localStorage.removeItem("appFileMeta");
  localStorage.removeItem("recentFiles:admin");
  localStorage.removeItem("currentUser");


  // Clear everything else
  localStorage.clear();

  // Redirect
  setTimeout(() => {
    window.location.href = "Loginscreen.html";
  }, 500);

  return "üßπ All data (including admin) deleted. Restarting...";
});


registerCommand("runbridge", () => {
  const raw = localStorage.getItem("runbridge");
  if (!raw) return "üì≠ No runbridge commands found.";

  let commands;
  try {
    commands = JSON.parse(raw);
    if (!Array.isArray(commands)) throw new Error();
  } catch {
    return "‚ùå Runbridge data is corrupted or not a list.";
  }

  if (commands.length === 0) {
    localStorage.removeItem("runbridge");
    return "üì≠ Runbridge queue is empty.";
  }

  // Clear before running to support self-referential "runbridge"
  localStorage.removeItem("runbridge");

  commands.forEach((cmd, i) => {
    setTimeout(() => {
      handleCommand(cmd); // Including if it's "runbridge"
    }, i * 250);
  });

  return `üîÅ Running ${commands.length} command(s) from runbridge`;
});

registerCommand("bridgestatus", () => {
  const raw = localStorage.getItem("runbridge");

  if (!raw) return "üì≠ No commands queued in runbridge.";

  try {
    const commands = JSON.parse(raw);
    if (!Array.isArray(commands)) throw new Error();

    if (commands.length === 0) {
      return "üì≠ Runbridge is empty.";
    }

    const fullList = commands.map((cmd, i) => `  ${i + 1}. ${cmd}`).join("\n");
    return `üì¶ RunBridge Queue: ${commands.length} command(s)\n${fullList}`;
  } catch {
    return "‚ùå Runbridge data is corrupted or not in array format.";
  }
});

registerCommand("rmbridge", args => {
  const index = parseInt(args[0], 10);

  if (isNaN(index) || index < 1) {
    return "‚ùå Usage: rmbridge [command number]";
  }

  const raw = localStorage.getItem("runbridge");
  if (!raw) return "üì≠ No runbridge queue found.";

  let commands;
  try {
    commands = JSON.parse(raw);
    if (!Array.isArray(commands)) throw new Error();
  } catch {
    return "‚ùå Runbridge data is corrupted.";
  }

  if (index > commands.length) {
    return `‚ùå Command number ${index} is out of range (1‚Äì${commands.length}).`;
  }

  const removed = commands.splice(index - 1, 1);
  localStorage.setItem("runbridge", JSON.stringify(commands));

  return `üóëÔ∏è Removed command #${index}: "${removed[0]}"\nüì¶ ${commands.length} command(s) remaining in runbridge.`;
});


function isRunbridgeFirst() {
  try {
    const raw = localStorage.getItem("runbridge");
    const commands = JSON.parse(raw || "[]");
    if (!Array.isArray(commands) || commands.length === 0) return false;

    return commands[0].trim().toLowerCase() === "runbridge";
  } catch {
    return false;
  }
}



registerCommand("recents", () => {
  const user = localStorage.getItem("currentUser") || "admin";
  const recents = JSON.parse(localStorage.getItem(`recentFiles:${user}`) || "[]");

  if (recents.length === 0) {
    return `üïë No recent files found for ${user}.`;
  }

  const output = recents.slice().reverse().map((path, index) => {
    const name = path.split("/").pop();
    return `${index + 1}. ${name} ‚Äî ${path}`;
  }).join("\n");

  return `üïë Recent Files for ${user}:\n${output}`;
});



registerCommand("oos", () => {
  const winId = createWindow();
  const iframe = document.getElementById(`${winId}-content`);
  iframe.style.background = "#1e1e1e";
  iframe.src = "file-explorer.html"; // üëà Load external file here

  // Wait a moment, then send initial data
  setTimeout(() => {
    iframe.contentWindow?.postMessage({
      type: "fs-data",
      fs: fakeFileSystem,
      appMeta: JSON.parse(localStorage.getItem("appFileMeta") || "{}"),
      path: "/desktop"
    }, "*");
  }, 200);

  return `üóÇÔ∏è Opened GUI file explorer in window ${winId}`;
});


window.addEventListener("message", (e) => {
  const data = e.data;

  // ‚úÖ codetest.app wants to save a file and optionally open in nano
  if (data.type === "oos-nano-write" && typeof data.path === "string" && typeof data.content === "string") {
    const fullPath = data.path.startsWith("/") ? data.path : `${currentDir}/${data.path}`;
    localStorage.setItem("fileContent:" + fullPath, data.content);

    // üëá Open in nano if requested
    if (data.openEditor !== false) {
      handleCommand(`nano "${fullPath}"`);
    } else {
      terminalOutput(`üíæ Saved "${fullPath}"`);
    }

    return;
  }

  // ‚úÖ File Explorer (Recents or Grid) wants to launch an app via Terminal
  if (data.type === "apps" && typeof data.path === "string") {
    handleCommand(`launch "${data.path}"`);
    return;
  }

  // ‚úÖ File Explorer wants to open a file in nano
  if (data.type === "oos-nano" && typeof data.path === "string") {
    handleCommand(`nano "${data.path}"`);
    return;
  }

  // ‚úÖ Finder wants to navigate folder
  if (data.type === "oos-navigate" && typeof data.path === "string") {
    const iframe = [...document.querySelectorAll("iframe")].find(f => f.src.includes("finder.html"));
    if (iframe?.contentWindow) {
      iframe.contentWindow.postMessage({
        type: "fs-data",
        fs: fakeFileSystem,
        appMeta: JSON.parse(localStorage.getItem("appFileMeta") || "{}"),
        path: data.path
      }, "*");
    }
    return;
  }

  // ‚úÖ File Explorer or Finder requests full file system
  if (data.type === "request-fs") {
    const iframe = [...document.querySelectorAll("iframe")].find(f => f.src.includes("finder.html"));
    if (iframe?.contentWindow) {
      iframe.contentWindow.postMessage({
        type: "fs-data",
        fs: fakeFileSystem,
        appMeta: JSON.parse(localStorage.getItem("appFileMeta") || "{}"),
        path: currentDir
      }, "*");
    }
    return;
  }

  // ‚úÖ File move via drag-and-drop
  if (data.type === "move-file") {
    const { from, to, file } = data;
    const originalDir = currentDir;
    currentDir = from;

    const toFolderName = to.split("/").pop();
    handleCommand(`amendfile "${file}" "${toFolderName}"`);

    const iframe = [...document.querySelectorAll("iframe")].find(f => f.src.includes("finder.html"));
    if (iframe?.contentWindow) {
      iframe.contentWindow.postMessage({
        type: "fs-data",
        fs: fakeFileSystem,
        appMeta: JSON.parse(localStorage.getItem("appFileMeta") || "{}"),
        path: to
      }, "*");
    }

    currentDir = originalDir;
    return;
  }

  // ‚úÖ Open Finder window at given path
  if (data.type === "finder-open" && typeof data.path === "string") {
    const winId = createWindow();
    const iframe = document.getElementById(`${winId}-content`);
    iframe.src = "finder.html";

    setTimeout(() => {
      iframe.contentWindow?.postMessage({
        type: "fs-data",
        fs: fakeFileSystem,
        appMeta: JSON.parse(localStorage.getItem("appFileMeta") || "{}"),
        path: data.path
      }, "*");
    }, 200);
    return;
  }
});
registerCommand("overwrite", args => {
  const input = args.join(" ").trim();
  const match = input.match(/^\"(.+?)\"\s+\"\"\"([\s\S]*)\"\"\"$/);

  if (!match) {
    return '‚ùå Usage: overwrite "path" """content"""';
  }

  const path = match[1];
  const content = match[2];

  // Save the new content
  localStorage.setItem("fileContent:" + path, content);

  // Auto-close nano if open
  const nanoWindow = [...document.querySelectorAll("iframe")]
    .find(f => f.src.includes("nano.html") && f.dataset.file === path);

  if (nanoWindow) {
    const win = nanoWindow.closest(".window");
    win?.remove(); // closes the nano window
  }

  return `üíæ Overwritten and saved "${path}"`;
});



registerCommand("cut", args => {
  const name = args[0];
  if (!name) return '‚ùå Usage: cut "fileOrFolderName"';

  const fullPath = currentDir === "/" ? `/${name}` : `${currentDir}/${name}`;
  if (!fakeFileSystem[currentDir] || !fakeFileSystem[currentDir].includes(name)) {
    return `‚ùå "${name}" not found in current directory.`;
  }

  cutItem = {
    name,
    from: currentDir,
    isFolder: !!fakeFileSystem[fullPath]
  };

  return `‚úÇÔ∏è Cut "${name}" from ${currentDir}`;
});

registerCommand("paste", args => {
  if (!cutItem) return "‚ùå Nothing to paste.";

  const { name, from, isFolder } = cutItem;

  // Determine the destination directory
  let destination = currentDir;

  if (args[0] === "in") {
    const folderName = args[1];
    if (!folderName) return '‚ùå Usage: paste in "FolderName"';

    destination = currentDir === "/" ? `/${folderName}` : `${currentDir}/${folderName}`;

    if (!fakeFileSystem[destination]) {
      return `‚ùå Destination folder "${folderName}" does not exist.`;
    }
  }

  // Check that the item still exists
  if (!fakeFileSystem[from] || !fakeFileSystem[from].includes(name)) {
    cutItem = null;
    return `‚ùå Source item no longer exists.`;
  }

  // Remove from original directory
  fakeFileSystem[from] = fakeFileSystem[from].filter(i => i !== name);

  // Add to destination directory
  if (!fakeFileSystem[destination].includes(name)) {
    fakeFileSystem[destination].push(name);
  }

  // Define old and new full paths
  const oldPath = from === "/" ? `/${name}` : `${from}/${name}`;
  const newPath = destination === "/" ? `/${name}` : `${destination}/${name}`;

  // Move folder structure if it's a folder
  if (isFolder) {
    fakeFileSystem[newPath] = fakeFileSystem[oldPath];
    delete fakeFileSystem[oldPath];
  }

  // Move file content if needed
  const content = localStorage.getItem("fileContent:" + oldPath);
  if (content !== null) {
    localStorage.setItem("fileContent:" + newPath, content);
    localStorage.removeItem("fileContent:" + oldPath);
  }

  // ‚úÖ Move app metadata if it exists
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
  if (appMeta[oldPath]) {
    appMeta[newPath] = appMeta[oldPath];
    delete appMeta[oldPath];
    localStorage.setItem("appFileMeta", JSON.stringify(appMeta));
  }

  saveFileSystem();
  cutItem = null;

  return `üìã Pasted "${name}" into ${destination}`;
});



registerCommand("files", args => {
  let path = args[0] || currentDir;

  // Normalize the path
  if (!path.startsWith("/")) {
    path = currentDir === "/" ? `/${path}` : `${currentDir}/${path}`;
  }
  path = path.replace(/\/+/g, "/");

  // Check if the path exists and is a folder
  if (!fakeFileSystem[path] || !Array.isArray(fakeFileSystem[path])) {
    return `‚ùå Folder not found: ${path}`;
  }

  // Trigger the Finder
  window.postMessage({
    type: "finder-open",
    path: path
  }, "*");

  return `üß≠ Finder opened at ${path}`;
});
registerCommand("mkfile", args => {
  let rawPath = args[0]?.replace(/\"/g, "").trim();

  // Prompt if no path given
  if (!rawPath) {
    rawPath = prompt("Enter full file path (e.g. /desktop/test.txt):");
    if (!rawPath || !rawPath.includes("/")) return "‚ùå Invalid path.";
  }

  const segments = rawPath.split("/").filter(Boolean);
  if (segments.length === 0) return "‚ùå Invalid path.";

  const fileName = segments.pop();
  let currentPath = "/";

  // Build missing folders if needed
  for (const segment of segments) {
    const nextPath = normalizePath(currentPath + "/" + segment);
    if (!fakeFileSystem[nextPath]) {
      fakeFileSystem[nextPath] = [];
    }
    if (!fakeFileSystem[currentPath].includes(segment)) {
      fakeFileSystem[currentPath].push(segment);
    }
    currentPath = nextPath;
  }

  const fullPath = normalizePath(currentPath + "/" + fileName);

  // Add file to folder if not already present
  if (!fakeFileSystem[currentPath].includes(fileName)) {
    fakeFileSystem[currentPath].push(fileName);
    saveFileSystem();
  }

  // Create empty content
  localStorage.setItem("fileContent:" + fullPath, "");

  return `üìÑ Created file: ${fullPath}`;
});

function normalizePath(path) {
  return path.replace(/\/+/g, "/");
}


registerCommand("link", args => {
  const input = args.join(" ");
  const [filePart, commandPart] = input.split("=");

  const fileName = filePart?.trim()?.replace(/\"/g, "");
  const command = commandPart?.trim()?.replace(/\"/g, "");

  if (!fileName || !command) {
    return '‚ùå Usage: link example.oos="somecommand"';
  }

  const filePath = currentDir === "/" ? `/${fileName}` : `${currentDir}/${fileName}`;
  if (!fakeFileSystem[currentDir].includes(fileName)) {
    return `‚ùå File not found: ${fileName}`;
  }

  localStorage.setItem("fileContent:" + filePath, command);
  return `üîó Linked ${fileName} to command: ${command}`;
});

registerCommand("assign", args => {
  const fileName = args[0]?.replace(/\"/g, "");
  const option = args[1]?.toLowerCase(); // normalize the option
  const value = args[2]?.replace(/\"/g, "");

  if (!fileName || option !== "icon" || !value) {
    return `‚ùå Usage: assign "filename.oos" icon "icon.jpg"`;
  }

  // üîç Find the actual full path (search every folder)
  let filePath = null;
  for (const dir in fakeFileSystem) {
    if (fakeFileSystem[dir].includes(fileName)) {
      filePath = dir === "/" ? `/${fileName}` : `${dir}/${fileName}`;
      break;
    }
  }

  if (!filePath) {
    return `‚ùå File "${fileName}" not found in any directory.`;
  }

  // ‚úÖ Load or create metadata
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  if (!appMeta[filePath]) {
    appMeta[filePath] = {};
  }

  // ‚úÖ Store with lowercase key and correct structure
  appMeta[filePath].icon = value;
  appMeta[filePath].type = "app";

  localStorage.setItem("appFileMeta", JSON.stringify(appMeta));

  return `üñºÔ∏è Icon for "${fileName}" set to "${value}" at ${filePath}`;
});



registerCommand("checkdata", args => {
  const fileName = args[0]?.replace(/\"/g, "");
  if (!fileName) return '‚ùå Usage: checkdata "file.oos"';

  // Search through the file system to find the full path
  let filePath = null;
  for (const dir in fakeFileSystem) {
    if (fakeFileSystem[dir].includes(fileName)) {
      filePath = dir === "/" ? `/${fileName}` : `${dir}/${fileName}`;
      break;
    }
  }

  if (!filePath) {
    return `‚ùå File "${fileName}" not found in any directory.`;
  }

  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  const meta = appMeta[filePath];

  if (!meta) {
    return `‚ÑπÔ∏è No metadata assigned to "${fileName}" (${filePath})`;
  }

  let output = `üìÑ Metadata for "${fileName}" at ${filePath}:\n`;
  for (const [key, value] of Object.entries(meta)) {
    output += `‚Ä¢ ${key}: ${value}\n`;
  }

  return output;
});


registerCommand("copy", args => {
  const fullPath = args[0];
  if (!fullPath) return '‚ùå Usage: copy "/path/to/fileOrFolder"';

  // Extract the name and parent directory from the path
  const parts = fullPath.split("/").filter(Boolean);
  if (parts.length === 0) return '‚ùå Invalid path.';
  const name = parts[parts.length - 1];
  const parentPath = "/" + parts.slice(0, -1).join("/");

  // Check if file/folder exists at given path
  const exists = fakeFileSystem[parentPath]?.includes(name);
  if (!exists) return `‚ùå "${name}" not found at ${parentPath}`;

  copyItem = {
    name,
    from: parentPath,
    fullPath: fullPath,
    isFolder: !!fakeFileSystem[fullPath],
    fromUser: currentUser // keep tracking user if needed for pasting logic
  };

  return `üìã Copied "${name}" from ${currentUser}:${fullPath}`;
});


registerCommand("copypaste", args => {
  if (!copyItem) return "‚ùå Nothing to paste.";

  const { name, fullPath, isFolder, fromUser } = copyItem;
  const globalUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
  const globalAppMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");

  const userFS = globalUsers[currentUser] = globalUsers[currentUser] || {};
  const sourceFS = globalUsers[fromUser] || {};
  const sourceMeta = globalAppMeta;

  // Determine destination folder path
  let destination = currentDir;
  if (args[0] === "in") {
    const targetPath = args[1];
    if (!targetPath) return '‚ùå Usage: copypaste in "/folder/path"';

    const normalizedPath = targetPath.startsWith("/") ? targetPath : `${currentDir}/${targetPath}`;
    destination = normalizedPath.replace(/\/+/g, "/");
  }

  if (!userFS[destination]) return `‚ùå Destination folder "${destination}" does not exist.`;

  const destPath = destination === "/" ? `/${name}` : `${destination}/${name}`;

  if (userFS[destination].includes(name)) {
    return `‚ùå "${name}" already exists in ${destination}`;
  }

  userFS[destination].push(name);

  function deepCopyFolder(src, dst) {
    const items = sourceFS[src] || [];
    userFS[dst] = [];

    items.forEach(item => {
      const srcItemPath = `${src}/${item}`;
      const dstItemPath = `${dst}/${item}`;

      userFS[dst].push(item);

      if (sourceFS[srcItemPath]) {
        deepCopyFolder(srcItemPath, dstItemPath); // folder
      } else {
        const content = localStorage.getItem("fileContent:" + srcItemPath);
        if (content !== null) {
          localStorage.setItem("fileContent:" + dstItemPath, content);
        }

        if (sourceMeta[srcItemPath]) {
          globalAppMeta[dstItemPath] = structuredClone(sourceMeta[srcItemPath]);
        }
      }
    });
  }

  if (isFolder) {
    userFS[destPath] = [];
    deepCopyFolder(fullPath, destPath);
  } else {
    const content = localStorage.getItem("fileContent:" + fullPath);
    if (content !== null) {
      localStorage.setItem("fileContent:" + destPath, content);
    }

    if (sourceMeta[fullPath]) {
      globalAppMeta[destPath] = structuredClone(sourceMeta[fullPath]);
    }
  }

  // Save everything
  localStorage.setItem("userFileSystems", JSON.stringify(globalUsers));
  localStorage.setItem("appFileMeta", JSON.stringify(globalAppMeta));

  return `üìã Pasted copy of "${name}" into ${destination}`;
});


registerCommand("clearrec", () => {
  localStorage.removeItem("recentFiles");
  return "üßπ Recent files cleared!";
});

registerCommand("setback", args => {
  const imageName = args[0];
  if (!imageName) return "‚ùå Usage: setback [image-name or base64]";

  // Save the background for the current user
  localStorage.setItem(`desktopBackground:${currentUser}`, imageName);

  // Apply the background
  if (imageName.startsWith("data:image/")) {
    document.body.style.backgroundImage = `url('${imageName}')`;
    return `üñºÔ∏è Custom background set for ${currentUser}`;
  } else {
    localStorage.removeItem("customDesktopBackground");
    document.body.style.backgroundImage = `url('${imageName}')`;
    return `üñºÔ∏è Background image set to ${imageName} for ${currentUser}`;
  }
});

registerCommand("memory", () => {
  const totalQuota = 5 * 1024 * 1024; // 5MB
  let totalUsed = 0;

  const fileSizes = [];

  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      try {
        const value = localStorage.getItem(key);
        const size = key.length + value.length;
        totalUsed += size;
        fileSizes.push({ key, size });
      } catch (e) {
        // Skip unreadable keys
      }
    }
  }

  const percentUsed = ((totalUsed / totalQuota) * 100).toFixed(2);
  const usedKB = (totalUsed / 1024).toFixed(2);
  const quotaKB = (totalQuota / 1024).toFixed(2);

  // Sort largest to smallest
  fileSizes.sort((a, b) => b.size - a.size);

  const fileList = fileSizes.map(f => {
    const sizeKB = (f.size / 1024).toFixed(2);
    return `  ‚Ä¢ ${f.key} (${sizeKB} KB)`;
  }).join("\n");

  return `üì¶ Storage Info:
üß† Used: ${usedKB} KB / ${quotaKB} KB (${percentUsed}%)
üìÅ Keys Stored: ${fileSizes.length}

üîë Storage Breakdown:
${fileList}`;
});


registerCommand("clear", () => {
  terminal.innerHTML = "";
  commandHistory = [];
  historyIndex = -1;


});

// Register the "runlink" command
registerCommand("runlink", args => {
  const fileName = args[0]?.replace(/\"/g, "");
  if (!fileName) return '‚ùå Usage: runlink "file.oos"';

  // üîç Search for the full path to this file anywhere in the file system
  let filePath = null;
  for (const dir in fakeFileSystem) {
    if (fakeFileSystem[dir].includes(fileName)) {
      filePath = dir === "/" ? `/${fileName}` : `${dir}/${fileName}`;
      break;
    }
  }

  if (!filePath) {
    return `‚ùå File "${fileName}" not found in any directory.`;
  }

  const command = localStorage.getItem("fileContent:" + filePath);
  if (!command) {
    return `‚ùå No command linked to "${fileName}"`;
  }

  return handleCommand(command);
});
window.addEventListener("message", (e) => {
  const { type, command } = e.data;
  if (type === "terminal-input" && typeof command === "string") {
    const output = handleCommand(command); // runs 'runlink "/dock/example.oos"'
    printToTerminal(output); // or however you show output
  }
});

registerCommand("linkvar", args => {
  const input = args.join(" ");
  const [varPart, commandPart] = input.split("=");

  const varName = varPart?.trim()?.replace(/\"/g, "");
  const command = commandPart?.trim()?.replace(/\"/g, "");

  if (!varName || !command) {
    return '‚ùå Usage: linkvar variable="command string"';
  }

  localStorage.setItem("commandVar:" + varName, command);
  return `üîó Linked variable "${varName}" to: ${command}`;
});

registerCommand("runvar", args => {
  const varName = args[0];
  if (!varName) return '‚ùå Usage: runvar [variableName]';

  const command = localStorage.getItem("commandVar:" + varName);
  if (!command) return `‚ùå Variable "${varName}" not found.`;

  return handleCommand(command);
});

registerCommand("movedir", args => {
  const input = args.join(" ").split(" to ");
  if (input.length !== 2) return '‚ùå Usage: movedir /source/folder to /destination/folder';

  const sourcePath = input[0].trim().replace(/\"/g, "").replace(/\/+/g, "/");
  const destinationDir = input[1].trim().replace(/\"/g, "").replace(/\/+/g, "/");

  const folderName = sourcePath.split("/").pop();
  const sourceDir = sourcePath.substring(0, sourcePath.lastIndexOf("/")) || "/";

  if (!fakeFileSystem[sourcePath] || !Array.isArray(fakeFileSystem[sourcePath])) {
    return `‚ùå Folder not found or invalid: ${sourcePath}`;
  }

  if (!fakeFileSystem[destinationDir]) {
    return `‚ùå Destination folder "${destinationDir}" does not exist.`;
  }

  const destPath = `${destinationDir}/${folderName}`.replace(/\/+/g, "/");

  if (fakeFileSystem[destPath]) {
    return `‚ùå Folder already exists at destination: ${destPath}`;
  }

  // ‚úÖ Move folder
  fakeFileSystem[destPath] = [...fakeFileSystem[sourcePath]];
  fakeFileSystem[destPath]._isFolder = true;
  delete fakeFileSystem[sourcePath];

  fakeFileSystem[sourceDir] = fakeFileSystem[sourceDir].filter(item => item !== folderName);
  if (!fakeFileSystem[destinationDir].includes(folderName)) {
    fakeFileSystem[destinationDir].push(folderName);
  }

  saveFileSystem();

  // üîÑ Update appRegistry paths
  const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
  let changedRegistry = false;
  const oldPrefix = sourcePath.endsWith("/") ? sourcePath : sourcePath + "/";
  const newPrefix = destPath.endsWith("/") ? destPath : destPath + "/";

  Object.keys(registry).forEach(appName => {
    const app = registry[appName];
    if (app.file.startsWith(oldPrefix)) {
      app.file = app.file.replace(oldPrefix, newPrefix);
      changedRegistry = true;
    }
  });

  if (changedRegistry) {
    localStorage.setItem("appRegistry", JSON.stringify(registry));
  }

  // üîÑ Update appFileMeta paths
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
  const updatedMeta = {};
  let changedMeta = false;

  for (const key in appMeta) {
    if (key.startsWith(oldPrefix)) {
      const newKey = key.replace(oldPrefix, newPrefix);
      updatedMeta[newKey] = appMeta[key];
      changedMeta = true;
    } else {
      updatedMeta[key] = appMeta[key];
    }
  }

  if (changedMeta) {
    localStorage.setItem("appFileMeta", JSON.stringify(updatedMeta));
  }

  // ‚úÖ Move associated file content (HTML, .txt, etc.)
for (const key in localStorage) {
  if (key.startsWith("fileContent:" + oldPrefix)) {
    const newKey = key.replace(oldPrefix, newPrefix);
    const content = localStorage.getItem(key);
    localStorage.setItem(newKey, content);
    localStorage.removeItem(key);
  }
}


  return `üìÅ Moved folder "${folderName}" to ${destinationDir}`;
});


registerCommand("movefile", args => {
  const input = args.join(" ").split(" to ");
  if (input.length !== 2) return '‚ùå Usage: movefile /source/file.txt to /destination/folder';

  const sourcePath = input[0].trim().replace(/\"/g, "");
  const destinationDir = input[1].trim().replace(/\"/g, "");

  const fileName = sourcePath.split("/").pop();
  const sourceDir = sourcePath.substring(0, sourcePath.lastIndexOf("/")) || "/";
  const destPath = `${destinationDir}/${fileName}`;

  if (!fakeFileSystem[sourceDir] || !fakeFileSystem[sourceDir].includes(fileName)) {
    return `‚ùå File not found: ${sourcePath}`;
  }

  if (!fakeFileSystem[destinationDir]) {
    return `‚ùå Destination folder "${destinationDir}" does not exist.`;
  }

  // Move in file system
  fakeFileSystem[sourceDir] = fakeFileSystem[sourceDir].filter(item => item !== fileName);
  if (!fakeFileSystem[destinationDir].includes(fileName)) {
    fakeFileSystem[destinationDir].push(fileName);
  }

  // Normalize localStorage keys
  const oldKey = `fileContent:${sourcePath}`;
  const newKey = `fileContent:${destPath}`;

  const content = localStorage.getItem(oldKey);
  if (content !== null) {
    localStorage.setItem(newKey, content);
    localStorage.removeItem(oldKey);
  }

  // Move metadata
  moveAppMeta(fileName, destPath);

  saveFileSystem();
  return `üìÑ Moved file "${fileName}" to ${destinationDir}`;
});




registerCommand("rename", args => {
  const input = args.join(" ").split(" to ");
  if (input.length !== 2) return '‚ùå Usage: rename /path/to/item to newName';

  const oldPath = input[0].trim();
  const newName = input[1].trim();

  if (!oldPath.startsWith("/")) return '‚ùå Source path must start with "/"';

  const parentDir = oldPath.substring(0, oldPath.lastIndexOf("/")) || "/";
  const oldName = oldPath.split("/").pop();
  const newPath = parentDir === "/" ? `/${newName}` : `${parentDir}/${newName}`;

  if (!fakeFileSystem[oldPath] && !fakeFileSystem[parentDir]?.includes(oldName)) {
    return `‚ùå "${oldName}" not found in ${parentDir}`;
  }

  // Check if new name already exists
  if (fakeFileSystem[newPath] || fakeFileSystem[parentDir]?.includes(newName)) {
    return `‚ùå "${newName}" already exists in ${parentDir}`;
  }

  // Rename in directory listing
  const index = fakeFileSystem[parentDir].indexOf(oldName);
  if (index !== -1) fakeFileSystem[parentDir][index] = newName;

  // Handle folders
  if (fakeFileSystem[oldPath]) {
    fakeFileSystem[newPath] = fakeFileSystem[oldPath];
    delete fakeFileSystem[oldPath];
  }

  // Move file content
  const fileContentKeyOld = "fileContent:" + oldPath;
  const fileContentKeyNew = "fileContent:" + newPath;
  const content = localStorage.getItem(fileContentKeyOld);
  if (content !== null) {
    localStorage.setItem(fileContentKeyNew, content);
    localStorage.removeItem(fileContentKeyOld);
  }

  // Move metadata
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  if (appMeta[oldPath]) {
    appMeta[newPath] = appMeta[oldPath];
    delete appMeta[oldPath];
    localStorage.setItem("appFileMeta", JSON.stringify(appMeta));
  }

  saveFileSystem();
  return `‚úèÔ∏è Renamed "${oldName}" to "${newName}"`;
});

registerCommand("clearrecents", () => {
  const user = localStorage.getItem("currentUser");
  if (!user) return "‚ùå No user signed in.";

  localStorage.removeItem(`recentFiles:${user}`);
  return "üßπ Cleared recent file history.";
});


const activeLoops = {};

registerCommand("loop", args => {
  const input = args.join(" ").trim();

  // Extract optional "then (...) as name"
  const thenAsMatch = input.match(/^(.*?)\s+then\s+\((.+?)\)(?:\s+as\s+(\w+))?$/);
  const asMatch = input.match(/^(.*?)\s+as\s+(\w+)$/);

  let main = input;
  let thenCommands = null;
  let loopName = null;

  if (thenAsMatch) {
    main = thenAsMatch[1].trim();
    thenCommands = thenAsMatch[2].trim();
    loopName = thenAsMatch[3]?.trim();
  } else if (asMatch) {
    main = asMatch[1].trim();
    loopName = asMatch[2].trim();
  }

  const baseMatch = main.match(/^\((.+?)\)\s+(.*)$/);
  if (!baseMatch) return "‚ùå Usage: loop (command) [count|forever|every Nms [count]|until command] [then (...)] [as name]";

  const raw = baseMatch[1].trim();
  const control = baseMatch[2].trim().toLowerCase();
  const runCommands = () => raw.split(":").forEach(cmd => handleCommand(cmd.trim()));

  // loop (cmd) 5
  if (/^\d+$/.test(control)) {
    const count = parseInt(control);
    for (let i = 0; i < count; i++) runCommands();
    if (thenCommands) thenCommands.split(":").forEach(cmd => handleCommand(cmd.trim()));
    return `üîÅ Ran command group ${count} times.`;
  }

  // loop (cmd) forever
  if (control === "forever") {
    const id = setInterval(runCommands, 500);
    const key = loopName || `forever:${raw}`;
    activeLoops[key] = id;
    return `‚ôæÔ∏è Looping commands forever${loopName ? ` as "${loopName}"` : ""}.`;
  }

  // loop (cmd) every 1000ms [count]
  const everyMatch = control.match(/^every\s+(\d+)ms(?:\s+(\d+))?$/);
  if (everyMatch) {
    const ms = parseInt(everyMatch[1]);
    const limit = everyMatch[2] ? parseInt(everyMatch[2]) : null;
    let count = 0;
    const key = loopName || `every${ms}:${raw}`;

    const interval = setInterval(() => {
      runCommands();
      count++;
      if (limit && count >= limit) {
        clearInterval(interval);
        delete activeLoops[key];
        if (thenCommands) thenCommands.split(":").forEach(cmd => handleCommand(cmd.trim()));
      }
    }, ms);

    activeLoops[key] = interval;
    return limit
      ? `‚è±Ô∏è Looping every ${ms}ms (${limit} times)${loopName ? ` as "${loopName}"` : ""}.`
      : `‚è±Ô∏è Looping every ${ms}ms${loopName ? ` as "${loopName}"` : ""}.`;
  }

  // loop (cmd) until stopCommand
  const untilMatch = control.match(/^until\s+(\w+)$/);
  if (untilMatch) {
    const stopper = untilMatch[1];
    const key = loopName || `until:${stopper}:${raw}`;
    const interval = setInterval(runCommands, 300);
    activeLoops[key] = interval;

    const original = commandRegistry[stopper];
    commandRegistry[stopper] = (...args) => {
      clearInterval(interval);
      delete activeLoops[key];
      commandRegistry[stopper] = original;
      if (thenCommands) thenCommands.split(":").forEach(cmd => handleCommand(cmd.trim()));
      return original ? original(args) : `üõë Stopped loop on "${stopper}".`;
    };

    return `‚è≥ Looping until "${stopper}" is called${loopName ? ` as "${loopName}"` : ""}.`;
  }

  return "‚ùå Invalid loop format.";
});

registerCommand("endloop", args => {
  const input = args.join(" ").trim();
  const match = input.match(/^\((.+?)\)$/);

  if (match) {
    const commandToRun = match[1].trim();
    const loopKeys = Object.keys(activeLoops);

    if (loopKeys.length === 0) return "‚ùå No active loops to end.";
    const lastKey = loopKeys[loopKeys.length - 1];
    clearInterval(activeLoops[lastKey]);
    delete activeLoops[lastKey];
    commandToRun.split(":").forEach(cmd => handleCommand(cmd.trim()));
    return `üõë Stopped latest loop and ran "${commandToRun}"`;
  }

  const name = input.trim();
  if (!activeLoops[name]) return `‚ùå No loop found named "${name}"`;
  clearInterval(activeLoops[name]);
  delete activeLoops[name];
  return `üõë Loop "${name}" stopped.`;
});


registerCommand("stoploop", () => {
  const keys = Object.keys(activeLoops);
  keys.forEach(key => {
    clearInterval(activeLoops[key]);
    delete activeLoops[key];
  });
  return keys.length ? `üßπ Stopped ${keys.length} loop(s).` : "‚ùå No loops to stop.";
});



registerCommand("delete", args => {
  let fullPath = args[0]?.trim();

  // üõë Prevent invalid usage or deleting root itself
  if (!fullPath || !fullPath.startsWith("/") || fullPath === "/") {
    return '‚ùå Cannot delete root directory. Usage: delete /path/to/item';
  }

  // Normalize path
  fullPath = fullPath.replace(/\/+/g, "/");

  const segments = fullPath.split("/").filter(Boolean);
  let itemName = segments.pop();
  const parentPath = "/" + segments.join("/");

  const parentList = fakeFileSystem[parentPath];
  if (!parentList || !Array.isArray(parentList)) {
    return `‚ùå Parent folder "${parentPath}" not found.`;
  }

  // Fuzzy match itemName if it's slightly mismatched
  const actualItem = parentList.find(i => i.trim() === itemName.trim());

  if (!actualItem) {
    return `‚ùå "${itemName}" does not exist in ${parentPath}`;
  }

  const targetPath = parentPath === "/" ? `/${actualItem}` : `${parentPath}/${actualItem}`;
  const isFolder = !!fakeFileSystem[targetPath];

  // Remove from parent's list
  fakeFileSystem[parentPath] = parentList.filter(i => i !== actualItem);

  // Recursively delete folder contents or remove file
  function recursiveDelete(path) {
    if (fakeFileSystem[path]) {
      for (const item of fakeFileSystem[path]) {
        const nestedPath = path === "/" ? `/${item}` : `${path}/${item}`;
        recursiveDelete(nestedPath);
      }
      delete fakeFileSystem[path];
    } else {
      localStorage.removeItem("fileContent:" + path);
      const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
      if (appMeta[path]) {
        delete appMeta[path];
        localStorage.setItem("appFileMeta", JSON.stringify(appMeta));
      }
    }
  }

  recursiveDelete(targetPath);
  saveFileSystem();

  return `üóëÔ∏è Deleted ${isFolder ? "folder" : "file"}: ${targetPath}`;
});



registerCommand("view", args => {
  const path = args[0]?.trim();

  // View installed apps or users as fallback
  if (path === "apps") {
    const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
    return Object.entries(registry).map(([name, details]) => {
      return `üî∏ ${name} ‚ûú ${details.file}`;
    }).join("\n") || "üìÇ No apps installed.";
  }

  if (path === "users") {
    const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
    return `üë• Users:\n‚Ä¢ ${Object.keys(allUsers).join("\n‚Ä¢ ")}`;
  }

  // New: view /path/to/folder
  if (!path || !path.startsWith("/")) {
    return '‚ùå Usage: view /path/to/folder';
  }

  if (!fakeFileSystem[path]) {
    return `‚ùå Folder not found: ${path}`;
  }

  const items = fakeFileSystem[path];
  return `üìÇ Contents of ${path}:\n` + items.map(item => {
    const itemPath = path === "/" ? `/${item}` : `${path}/${item}`;
    return fakeFileSystem[itemPath] ? `[DIR] ${item}` : `     ${item}`;
  }).join("\n");
});


registerCommand("shutdown", () => {
  // Confirmation popup
  const overlay = document.createElement("div");
  overlay.style = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center;
    z-index: 9999;
  `;

  const popup = document.createElement("div");
  popup.style = `
    background: #1e1e1e; padding: 25px 30px; border-radius: 15px;
    font-family: sans-serif; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    max-width: 300px; text-align: center; color: white;
  `;
  popup.innerHTML = `
    <p style="margin: 0; font-size: 16px;">Are you sure you want to shut down?</p>
    <div style="margin-top: 20px;">
      <button id="cancelShutdown" style="
        background: #444; color: white; border: none; padding: 8px 16px;
        border-radius: 8px; margin-right: 10px; cursor: pointer;
      ">Cancel</button>
      <button id="confirmShutdown" style="
        background: #007aff; color: white; border: none; padding: 8px 16px;
        border-radius: 8px; cursor: pointer;
      ">Shut Down</button>
    </div>
  `;

  overlay.appendChild(popup);
  document.body.appendChild(overlay);

  // Cancel button
  document.getElementById("cancelShutdown").onclick = () => {
    document.body.removeChild(overlay);
  };

  // Confirm shutdown
  document.getElementById("confirmShutdown").onclick = () => {
    document.body.removeChild(overlay); // remove popup before showing overlay

    // Begin shutdown sequence
    const shutdownOverlay = document.createElement("div");
    shutdownOverlay.id = "shutdown-overlay";
    shutdownOverlay.style.position = "fixed";
    shutdownOverlay.style.top = 0;
    shutdownOverlay.style.left = 0;
    shutdownOverlay.style.width = "100vw";
    shutdownOverlay.style.height = "100vh";
    shutdownOverlay.style.background = "black";
    shutdownOverlay.style.zIndex = 9999;
    shutdownOverlay.style.display = "flex";
    shutdownOverlay.style.alignItems = "center";
    shutdownOverlay.style.justifyContent = "center";
    shutdownOverlay.style.flexDirection = "column";
    shutdownOverlay.style.color = "#00ff88";
    shutdownOverlay.style.fontFamily = "monospace";
    shutdownOverlay.style.fontSize = "24px";
    shutdownOverlay.style.opacity = 0;
    shutdownOverlay.style.transition = "opacity 1s ease";

    shutdownOverlay.innerHTML = `
      <div>Shutting down OOS...</div>
      <div style="font-size:12px; margin-top:10px;">Goodbye.</div>
    `;

    document.body.appendChild(shutdownOverlay);
    requestAnimationFrame(() => {
      shutdownOverlay.style.opacity = 1;
    });

    setTimeout(() => {
      shutdownOverlay.innerHTML = `
        <div style='opacity: 0.5;'>System powered off.<br>Press SPACE to turn on.</div>
      `;
    }, 2500);

    function onKey(e) {
      if (e.code === "Space") {
        document.removeEventListener("keydown", onKey);
        window.location.href = "Loginscreen.html";
      }
    }

    document.addEventListener("keydown", onKey);
  };

  return ""; // no output in terminal
});

registerCommand("sleep", () => {
  const overlay = document.createElement("div");
  overlay.id = "sleep-overlay";
  overlay.style.position = "fixed";
  overlay.style.top = 0;
  overlay.style.left = 0;
  overlay.style.width = "100vw";
  overlay.style.height = "100vh";
  overlay.style.background = "black";
  overlay.style.zIndex = 9999;
  overlay.style.display = "flex";
  overlay.style.alignItems = "center";
  overlay.style.justifyContent = "center";
  overlay.style.flexDirection = "column";
  overlay.style.color = "#00ff88";
  overlay.style.fontFamily = "monospace";
  overlay.style.fontSize = "24px";
  overlay.style.opacity = 0;
  overlay.style.transition = "opacity 1s ease";

  overlay.innerHTML = `
    <div>üí§ Entering Sleep Mode...</div>
    <div style="font-size:12px; margin-top:10px;">Press SPACE to wake</div>
  `;

  document.body.appendChild(overlay);
  requestAnimationFrame(() => {
    overlay.style.opacity = 1;
  });

  // Listen for spacebar to wake up
  function onWakeKey(e) {
    if (e.code === "Space") {
      document.removeEventListener("keydown", onWakeKey);
      overlay.style.transition = "opacity 0.5s ease";
      overlay.style.opacity = 0;

      setTimeout(() => {
        overlay.remove();
      }, 500);
    }
  }

  document.addEventListener("keydown", onWakeKey);

  return "üí§ System sleeping. Press space to wake.";
});

registerCommand("setpass", args => {
  const password = args[0]?.trim();
  if (!currentUser) return "‚ùå No user signed in.";
  if (!password) return "‚ùå Usage: setpass [password]";

  const passwords = JSON.parse(localStorage.getItem("userPasswords") || "{}");

  // If admin is viewing another user, set password for that user
  const targetUser = viewingUser || currentUser;

  passwords[targetUser] = password;
  localStorage.setItem("userPasswords", JSON.stringify(passwords));

  return `üîí Password set for user "${targetUser}"`;
});


registerCommand("viewdir", args => {
  const path = args[0]?.trim();
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});

  if (!path || !path.startsWith("/")) {
    return '‚ùå Usage: viewdir /path/to/folder';
  }

  if (!fakeFileSystem[path] || !Array.isArray(fakeFileSystem[path])) {
    return `‚ùå Folder not found: ${path}`;
  }

  const items = fakeFileSystem[path];
  if (items.length === 0) return `üìÇ ${path} is empty.`;

  return `üìÇ Contents of ${path}:\n` + items.map(item => {
    const itemPath = path === "/" ? `/${item}` : `${path}/${item}`;

    if (Array.isArray(fakeFileSystem[itemPath])) {
      return `[DIR]  ${item}`;
    } else if (appMeta[itemPath]) {
      return `[APP]  ${item}`;
    } else {
      return `[FILE] ${item}`;
    }
  }).join("\n");
});

registerCommand("downloaddata", async () => {
  const zip = new JSZip();

  // Include known main keys
  const keysToBackup = [
    "userFileSystems",
    "appRegistry",
    "appFileMeta",
    "recentFiles",
    "userPasswords",
  ];

  keysToBackup.forEach(key => {
    const value = localStorage.getItem(key);
    if (value) {
      zip.file(`${key}.json`, value);
    }
  });

  // Include all file contents
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key.startsWith("fileContent:")) {
      const filePath = key.replace("fileContent:", "");
      const content = localStorage.getItem(key);
      if (content !== null) {
        zip.file(`files${filePath}`, content);
      }
    }

    if (key.startsWith("commandVar:")) {
      const varName = key.replace("commandVar:", "");
      const content = localStorage.getItem(key);
      if (content !== null) {
        zip.file(`variables/${varName}.txt`, content);
      }
    }
  }

  try {
    const blob = await zip.generateAsync({ type: "blob" });
    saveAs(blob, `OOS_backup_${new Date().toISOString().split("T")[0]}.zip`);
    return `üì¶ Downloaded all local data as a backup ZIP file.`;
  } catch (err) {
    return `‚ùå Error creating ZIP: ${err.message}`;
  }
});

registerCommand("seedata", args => {
  const path = args[0]?.replace(/\"/g, "");
  const fileName = args[1]?.replace(/\"/g, "");

  if (!path || !fileName) return '‚ùå Usage: seedata /path/ filename';

  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");

  // Construct full path (fix slashes)
  const cleanedPath = path.replace(/\/+$/, "");
  const fullPath = `${cleanedPath}/${fileName}`;

  // Exact match first
  if (appMeta[fullPath]) {
    const meta = appMeta[fullPath];
    return Object.entries(meta).map(([key, val]) => `‚Ä¢ ${key}: ${val}`).join("\n");
  }

  // üîç Fallback: scan all paths for matching filename
  const foundPath = Object.keys(appMeta).find(p => p.endsWith("/" + fileName));

  if (foundPath) {
    const meta = appMeta[foundPath];
    return `üìÇ Found at ${foundPath}\n` +
      Object.entries(meta).map(([key, val]) => `‚Ä¢ ${key}: ${val}`).join("\n");
  }

  return `‚ùå No metadata found for "${fileName}" in "${path}".`;
});
registerCommand("makefilegui", () => {
  const win = document.createElement("div");
  win.className = "window";
  Object.assign(win.style, {
    position: "absolute",
    left: "100px",
    top: "100px",
    width: "440px",
    height: "560px",
    background: "rgba(20, 20, 20, 0.95)",
    color: "#fff",
    fontFamily: "monospace",
    zIndex: zIndexCounter++,
    display: "flex",
    flexDirection: "column",
    borderRadius: "16px",
    border: "1px solid rgba(255,255,255,0.12)",
    boxShadow: "0 0 20px rgba(0,0,0,0.6)",
    overflow: "hidden"
  });

  let selectedFolder = "/";
  let selectedItem = null;

  win.innerHTML = `
    <div id="topbar" style="padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,0.1); font-weight: bold; font-size: 16px; display: flex; justify-content: space-between; align-items: center; cursor: move;">
      üìÑ File & Folder Creator
      <button style="background: none; border: none; color: #fff; font-size: 18px; cursor: pointer;">‚ùå</button>
    </div>
    <div id="folderTree" style="flex: 1; overflow-y: auto; padding: 10px 14px; font-size: 14px;"></div>
    <div style="padding: 12px 14px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; gap: 8px;">
      <input id="newFolderName" placeholder="New folder..." style="flex: 1; padding: 8px; background: #333; border: 1px solid #555; border-radius: 8px; color: white;" />
      <button id="createFolderBtn" style="padding: 8px 12px; background: #444; border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer;">üìÅ +</button>
    </div>
    <div style="padding: 12px 14px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; gap: 8px;">
      <div style="display: flex; gap: 8px;">
        <input id="newFileName" placeholder="File name" style="flex: 1; padding: 8px; background: #333; border: 1px solid #555; border-radius: 8px; color: white;" />
        <select id="fileType" style="width: 100px; padding: 8px; background: #333; border: 1px solid #555; border-radius: 8px; color: white;">
          <option value=".html">.html</option>
          <option value=".oos">.oos</option>
          <option value=".txt">.txt</option>
        </select>
      </div>
      <button id="createFileBtn" style="padding: 10px; background: #555; border: none; border-radius: 10px; color: white; font-weight: bold; cursor: pointer;">
        ‚úÖ Create File
      </button>
    </div>
    <div style="padding: 12px 14px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; gap: 8px;">
      <input id="deleteName" placeholder="Delete file/folder..." style="flex: 1; padding: 8px; background: #333; border: 1px solid #555; border-radius: 8px; color: white;" />
      <button id="deleteBtn" style="padding: 8px 12px; background: #aa2222; border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer;">üóëÔ∏è Delete</button>
    </div>
  `;

  document.body.appendChild(win);

  const folderTree = win.querySelector("#folderTree");

  function normalizePath(path) {
    return path.replace(/\/+/g, "/");
  }

  function renderFolderList(path = "/", level = 0) {
    const contents = fakeFileSystem[path] || [];
    contents.forEach(entry => {
      const fullPath = normalizePath(path + "/" + entry);
      const row = document.createElement("div");
      row.style.paddingLeft = `${level * 14}px`;
      row.style.cursor = "pointer";
      row.style.padding = "4px 6px";
      row.style.borderRadius = "6px";
      const isFolder = fakeFileSystem[fullPath];
      row.textContent = isFolder ? "üìÅ " + entry : "üìÑ " + entry;

      row.onclick = () => {
        selectedItem = entry;
        selectedFolder = isFolder ? fullPath : path;
        win.querySelector("#deleteName").value = "";
        renderAll();
      };

      if (entry === selectedItem) {
        row.style.background = "rgba(255,255,255,0.15)";
      }

      folderTree.appendChild(row);
      if (isFolder) {
        renderFolderList(fullPath, level + 1);
      }
    });
  }

  function renderAll() {
    folderTree.innerHTML = "";
    const rootRow = document.createElement("div");
    rootRow.textContent = "üìÇ /";
    rootRow.style.fontWeight = "bold";
    rootRow.style.cursor = "pointer";
    rootRow.style.padding = "4px 6px";
    rootRow.style.borderRadius = "6px";
    if (selectedFolder === "/") {
      rootRow.style.background = "rgba(255,255,255,0.1)";
    }
    rootRow.onclick = () => {
      selectedFolder = "/";
      selectedItem = null;
      renderAll();
    };
    folderTree.appendChild(rootRow);
    renderFolderList("/", 1);
  }

  win.querySelector("#createFileBtn").onclick = () => {
    const fileName = win.querySelector("#newFileName").value.trim();
    const fileExt = win.querySelector("#fileType").value;
    if (!fileName) return alert("‚ö†Ô∏è Enter a file name.");
    const finalName = fileName + fileExt;

    if (!fakeFileSystem[selectedFolder]) fakeFileSystem[selectedFolder] = [];

    if (!fakeFileSystem[selectedFolder].includes(finalName)) {
      fakeFileSystem[selectedFolder].push(finalName);
      localStorage.setItem(`fileContent:${selectedFolder}/${finalName}`, "");
      saveFileSystem();
      alert(`‚úÖ Created ${finalName} in ${selectedFolder}`);
      renderAll();
    } else {
      alert("‚ùå File already exists.");
    }
  };

  win.querySelector("#createFolderBtn").onclick = () => {
    const folderName = win.querySelector("#newFolderName").value.trim();
    if (!folderName) return alert("‚ö†Ô∏è Enter a folder name.");
    const fullPath = normalizePath(selectedFolder + "/" + folderName);

    if (!fakeFileSystem[fullPath]) {
      fakeFileSystem[fullPath] = [];
      if (!fakeFileSystem[selectedFolder]) fakeFileSystem[selectedFolder] = [];
      if (!fakeFileSystem[selectedFolder].includes(folderName)) {
        fakeFileSystem[selectedFolder].push(folderName);
      }
      saveFileSystem();
      renderAll();
    } else {
      alert("‚ùå Folder already exists.");
    }
  };

  win.querySelector("#deleteBtn").onclick = () => {
    const inputValue = win.querySelector("#deleteName").value.trim();
    const toDelete = inputValue || selectedItem;
    if (!toDelete) return alert("‚ö†Ô∏è No file or folder selected.");
    handleCommand(`rm "${toDelete}"`);
    selectedItem = null;
    renderAll();
  };

  win.querySelector("button").onclick = () => {
    document.body.removeChild(win);
  };

  // ‚ûï Draggable window support
  const topbar = win.querySelector("#topbar");
  let isDragging = false, offsetX = 0, offsetY = 0;

  topbar.addEventListener("mousedown", e => {
    isDragging = true;
    offsetX = e.clientX - win.offsetLeft;
    offsetY = e.clientY - win.offsetTop;
    win.style.zIndex = zIndexCounter++;
  });

  document.addEventListener("mousemove", e => {
    if (isDragging) {
      win.style.left = `${e.clientX - offsetX}px`;
      win.style.top = `${e.clientY - offsetY}px`;
    }
  });

  document.addEventListener("mouseup", () => isDragging = false);

  renderAll();
  return "üìÇ File + folder creator window opened.";
});



registerCommand("mkdir", args => {
  let rawPath = args[0]?.replace(/\"/g, "").trim();

  // Prompt if no path was provided
  if (!rawPath) {
    rawPath = prompt("Enter full folder path (e.g. /desktop/projects):");
    if (!rawPath || !rawPath.includes("/")) return "‚ùå Invalid folder path.";
  }

  const segments = rawPath.split("/").filter(Boolean);
  if (segments.length === 0) return "‚ùå Invalid folder path.";

  let currentPath = "/";
  for (const segment of segments) {
    const nextPath = normalizePath(currentPath + "/" + segment);

    // Create folder object if missing
    if (!fakeFileSystem[nextPath]) {
      fakeFileSystem[nextPath] = [];
    }

    // Add folder name to its parent directory
    if (!fakeFileSystem[currentPath].includes(segment)) {
      fakeFileSystem[currentPath].push(segment);
    }

    currentPath = nextPath;
  }

  saveFileSystem();
  return `üìÅ Created folder: ${normalizePath("/" + segments.join("/"))}`;
});
function normalizePath(path) {
  return path.replace(/\/+/g, "/");
}


registerCommand("reset", args => {
  const target = args[0] || currentUser;

  if (target !== currentUser && currentUser !== "admin") {
    return "‚ùå Only admin can reset other users.";
  }

  const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || {});
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
  const userPasswords = JSON.parse(localStorage.getItem("userPasswords") || {});
  const isCurrent = target === currentUser;

  if (!allUsers[target]) return `‚ùå User "${target}" does not exist.`;

  // Confirm reset
  const confirmed = confirm(`‚ö†Ô∏è Are you sure you want to reset "${target}" to a fresh state? This will erase all data.`);
  if (!confirmed) return "‚ùå Reset cancelled.";

  // Clear fileContent and metadata for this user
  for (const key in localStorage) {
    if (
      key.startsWith("fileContent:/") ||
      key.startsWith("recentFiles:") ||
      key.startsWith(`desktopBackground:${target}`)
    ) {
      const pathOwner = key.includes(":") ? key.split(":")[1].split("/")[0] : null;
      if (pathOwner === target || isCurrent) {
        localStorage.removeItem(key);
      }
    }
  }

  // Remove app metadata paths owned by this user
  for (const path in appMeta) {
    if (path.startsWith("/") && appMeta[path]) {
      const ownerFS = allUsers[target] || {};
      const pathFolder = path.substring(0, path.lastIndexOf("/"));
      const fileName = path.split("/").pop();
      if (ownerFS[pathFolder]?.includes(fileName)) {
        delete appMeta[path];
      }
    }
  }

  localStorage.setItem("appFileMeta", JSON.stringify(appMeta));

  // Reset file system structure
  allUsers[target] = {
    "/": ["apps", "dock", "desktop"],
    "/apps": [],
    "/desktop": [],
    "/dock": []
  };

  localStorage.setItem("userFileSystems", JSON.stringify(allUsers));

  if (isCurrent) {
    fakeFileSystem = structuredClone(allUsers[target]);
    currentDir = "/";
  }

  return `‚úÖ User "${target}" has been reset to a clean state.`;
});

registerCommand("deletedir", args => {
  const dirPath = args[0];
  if (!dirPath || !dirPath.startsWith("/")) {
    return '‚ùå Usage: deletedir /path/to/folder';
  }

  const normalizedPath = dirPath.replace(/\/+$/, ""); // remove trailing slashes

  if (!fakeFileSystem[normalizedPath]) {
    return `‚ùå Folder not found: ${normalizedPath}`;
  }

  const protected = ["/apps", "/dock", "/desktop"];
  if (protected.includes(normalizedPath)) {
    return "‚ùå Cannot delete protected system folders like /apps or /dock.";
  }

  const confirmed = confirm(`‚ö†Ô∏è Are you sure you want to delete the entire folder "${normalizedPath}" and all its contents?`);
  if (!confirmed) return "‚ùå Deletion cancelled.";

  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
  const toDeletePaths = [];

  function collectPaths(path) {
    if (!fakeFileSystem[path]) return;

    for (const item of fakeFileSystem[path]) {
      const fullPath = path === "/" ? `/${item}` : `${path}/${item}`;
      if (fakeFileSystem[fullPath]) {
        collectPaths(fullPath); // recurse into folder
        toDeletePaths.push(fullPath);
      } else {
        toDeletePaths.push(fullPath);
      }
    }

    toDeletePaths.push(path); // delete the folder itself last
  }

  collectPaths(normalizedPath);

  // Remove all collected paths
  for (const path of toDeletePaths) {
    if (fakeFileSystem[path]) {
      delete fakeFileSystem[path];
    }

    const fileName = path.split("/").pop();
    const parentDir = path.substring(0, path.lastIndexOf("/")) || "/";

    // Remove from parent dir listing
    if (fakeFileSystem[parentDir]) {
      fakeFileSystem[parentDir] = fakeFileSystem[parentDir].filter(i => i !== fileName);
    }

    // Remove metadata
    localStorage.removeItem("fileContent:" + path);
    delete appMeta[path];
  }

  localStorage.setItem("appFileMeta", JSON.stringify(appMeta));
  saveFileSystem();

  return `üóëÔ∏è Deleted folder and contents: ${normalizedPath}`;
});

registerCommand("string", args => {
  const full = args.join(" ").trim();
  const [namePart, valuePart] = full.split("=");

  if (!namePart || !valuePart || !valuePart.startsWith("(") || !valuePart.endsWith(")")) {
    return '‚ùå Usage: string name=("var", "text", var2)';
  }

  const name = namePart.trim();
  const content = valuePart.slice(1, -1); // remove surrounding ()
  const parts = content.split(",").map(p => p.trim());

  let result = "";

  for (let part of parts) {
    if (part.startsWith('"') && part.endsWith('"')) {
      result += part.slice(1, -1); // raw text
    } else {
      const value = localStorage.getItem("stringvar:" + part);
      if (value !== null) {
        result += value;
      } else {
        return `‚ùå Unknown variable: ${part}`;
      }
    }
  }

  // Save result and raw parts
  localStorage.setItem("stringvar:" + name, result);
  localStorage.setItem("stringraw:" + name, parts.join("||"));
  return `‚úÖ Created string "${name}": ${result}`;
});


registerCommand("setvar", args => {
  if (args.length < 3) return "‚ùå Usage: setvar varname == value";

  const [name, eq, ...valueParts] = args;

  if (eq !== "==") return '‚ùå Syntax error: expected "==", like: setvar myVar == value';

  const value = valueParts.join(" ");
  if (!value) return "‚ùå Value cannot be empty";

  localStorage.setItem("stringvar:" + name, value);
  return `‚úÖ Set variable "${name}" to "${value}"`;
});

registerCommand("showvar", args => {
  const name = args[0];
  if (!name) return "‚ùå Usage: showvar varname";
  const value = localStorage.getItem("stringvar:" + name);
  if (value === null) return `‚ö†Ô∏è Variable "${name}" not found.`;
  return `üì¶ ${name} = ${value}`;
});


registerCommand("fetchstring", args => {
  const [name, indexStr] = args;
  const index = parseInt(indexStr, 10);

  if (!name || isNaN(index)) {
    return '‚ùå Usage: fetchstring [name] [index]';
  }

  const raw = localStorage.getItem("stringraw:" + name);
  if (!raw) {
    return `‚ùå String "${name}" not found or not created with 'string' command.`;
  }

  const parts = raw.split("||").map(p => p.trim());

  if (index < 1 || index > parts.length) {
    return `‚ùå Index out of range (1-${parts.length})`;
  }

  const selected = parts[index - 1];

  // If quoted, strip it
  const cleaned = selected.startsWith('"') && selected.endsWith('"')
    ? selected.slice(1, -1)
    : (localStorage.getItem("stringvar:" + selected) || selected);

  // Save to temp var
  localStorage.setItem("stringvar:_lastfetch", cleaned);

  return cleaned;
});

// Permission Management (chmod)


registerCommand("find", args => {
  const query = args.join(" ").replace(/\"/g, "").toLowerCase();
  if (!query) return '‚ùå Usage: find "searchTerm"';

  const results = [];
  const appRegistry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");

  function searchDirectory(currentPath) {
    const items = fakeFileSystem[currentPath];

    items.forEach(item => {
      const itemLower = item.toLowerCase();
      const fullPath = currentPath === "/" ? `/${item}` : `${currentPath}/${item}`;

      // Check if item matches query
      if (itemLower.includes(query)) {
        let type = "[FILE]"; // default type

        if (fakeFileSystem[fullPath]) {
          type = "[FOLDER]";
        } else if (appRegistry[item] || (appMeta[fullPath] && appMeta[fullPath].type === "app")) {
          type = "[APP]";
        } else if (itemLower.endsWith(".oos")) {
          type = "[OOS FILE]";
        }

        results.push(`${type} ${fullPath}`);
      }

      // Recursive search if folder
      if (fakeFileSystem[fullPath]) {
        searchDirectory(fullPath);
      }
    });
  }

  // Start search from root "/"
  searchDirectory("/");

  if (results.length === 0) {
    return `üîç No matches found for "${query}".`;
  }

  return `üîç Matches for "${query}":\n${results.join("\n")}`;
});

registerCommand("setuser", args => {
  const option = args[0]?.toLowerCase();
  const value = args[1];

  if (option !== "icon" || !value) {
    return '‚ùå Usage: setuser icon [filename.jpg]';
  }

  const username = localStorage.getItem("currentUser") || "admin";
  const userIcons = JSON.parse(localStorage.getItem("userIcons") || "{}");

  userIcons[username] = value;
  localStorage.setItem("userIcons", JSON.stringify(userIcons));

  return `üñºÔ∏è Set icon for user "${username}" to "${value}"`;
});

registerCommand("getuser", args => {
  const option = args[0]?.toLowerCase();
  if (option !== "icon") return '‚ùå Usage: getuser icon';

  const username = localStorage.getItem("currentUser") || "admin";
  const userIcons = JSON.parse(localStorage.getItem("userIcons") || "{}");

  const icon = userIcons[username] || "‚ùå No icon set.";
  return `üë§ Icon for "${username}": ${icon}`;
});



registerCommand("rmdup", args => {
  const fileName = args[0];
  if (!fileName) return '‚ùå Usage: rmdup "file.html"';

  const keepPath = `/apps/${fileName}`;
  let removedCount = 0;

  for (const path in fakeFileSystem) {
    if (Array.isArray(fakeFileSystem[path])) {
      if (path !== "/apps" && fakeFileSystem[path].includes(fileName)) {
        fakeFileSystem[path] = fakeFileSystem[path].filter(f => f !== fileName);
        removedCount++;
      }
    }
  }

  saveFileSystem();
  return removedCount
    ? `üßπ Removed ${removedCount} duplicates of "${fileName}" (kept copy in /apps)`
    : `‚úÖ No duplicates found outside /apps`;
});



//THE MOST IMPORTANT THING I HAVE MADE ALLOWS HTML APPS TO SUBMIT CONSOLE COMMANDS
window.terminalAPI = {
  run: (commandString) => {
    // Executes terminal commands like "cd /apps", "nano file.txt"
    return handleCommand(commandString);
  },
  getFileSystem: () => {
    // Returns a copy of the file system
    return structuredClone(fakeFileSystem);
  },
  saveFileSystem: () => {
    // Forces a save of the current FS to localStorage
    saveFileSystem();
  },
  getCurrentUser: () => {
    return currentUser;
  },
  getCurrentDir: () => {
    return currentDir;
  },
  setCurrentDir: (newPath) => {
    currentDir = newPath;
  },
  getFileContent: (filePath) => {
    return localStorage.getItem("fileContent:" + filePath) || "";
  },
  setFileContent: (filePath, content) => {
    localStorage.setItem("fileContent:" + filePath, content);
  },
  getAppMeta: () => {
    return JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  },
  setAppMeta: (metaObj) => {
    localStorage.setItem("appFileMeta", JSON.stringify(metaObj));
  }
};


registerCommand("amendbridge", args => {
  const newCommand = args.join(" ").trim();
  if (!newCommand) return "‚ùå Usage: amendbridge [command to add]";

  let commands;
  try {
    commands = JSON.parse(localStorage.getItem("runbridge") || "[]");
    if (!Array.isArray(commands)) throw new Error();
  } catch {
    commands = []; // if corrupt, reset it
  }

  commands.push(newCommand);
  localStorage.setItem("runbridge", JSON.stringify(commands));

  return `‚ûï Added to runbridge queue (#${commands.length}): "${newCommand}"`;
});

registerCommand("clearbridge", () => {
  const existed = localStorage.getItem("runbridge");

  if (!existed) return "üì≠ Runbridge is already empty.";

  localStorage.removeItem("runbridge");
  return "üßπ Runbridge queue cleared.";
});

// üü¢ AUTO-RUN RUNBRIDGE IF IT'S FIRST
setTimeout(() => {
  try {
    const raw = localStorage.getItem("runbridge");
    const commands = JSON.parse(raw || "[]");
    if (commands[0]?.trim().toLowerCase() === "runbridge") {
      handleCommand("runbridge");
    }
  } catch (err) {
    console.warn("Runbridge auto-run failed:", err);
  }
}, 200);

setInterval(() => {
  try {
    const raw = localStorage.getItem("livebridge");
    if (!raw) return;

    let commands = JSON.parse(raw);
    if (!Array.isArray(commands) || commands.length === 0) return;

    // Execute and remove each command one by one
    commands.forEach((cmd, i) => {
      setTimeout(() => {
        handleCommand(cmd);
      }, i * 100); // small delay per command
    });

    // Clear after processing
    localStorage.removeItem("livebridge");

  } catch (e) {
    console.warn("Livebridge failed:", e);
  }
}, 500); // Check every 500ms

registerCommand("amendlivebridge", args => {
  const newCommand = args.join(" ").trim();
  if (!newCommand) return "‚ùå Usage: amendlivebridge [command]";

  let commands;
  try {
    commands = JSON.parse(localStorage.getItem("livebridge") || "[]");
    if (!Array.isArray(commands)) throw new Error();
  } catch {
    commands = [];
  }

  commands.push(newCommand);
  localStorage.setItem("livebridge", JSON.stringify(commands));

  return `‚ö° Sent to livebridge: "${newCommand}"`;
});
registerCommand("htmlnano", args => {
  const rawPath = args[0];
  if (!rawPath) return "‚ùå Usage: htmlnano [filePath.html]";

  // Normalize full path (absolute or relative)
  const filePath = rawPath.startsWith("/")
    ? rawPath
    : (currentDir === "/" ? `/${rawPath}` : `${currentDir}/${rawPath}`);

  const content = localStorage.getItem("fileContent:" + filePath);

  if (content === null) return `‚ùå File not found: ${filePath}`;

  const isFullHTML = content.includes("<html") && content.includes("</html>");

  if (isFullHTML) {
    const winId = createWindow();
    const iframe = document.getElementById(`${winId}-content`);
    iframe.srcdoc = content;
    return `üöÄ HTML from "${filePath}" launched in window ${winId}`;
  } else {
    handleCommand(`nano ${JSON.stringify(filePath)}`);
    return `‚úèÔ∏è Opened "${filePath}" in Nano`;
  }
});

registerCommand("chmod", args => {
  const action = args[0];
  const folderPath = args[1];

  let map = JSON.parse(localStorage.getItem("lockedFolderMap") || "{}");

  if (action === "lock") {
    if (!fakeFileSystem[folderPath]) return `‚ùå Folder not found: ${folderPath}`;
    if (map[folderPath]) return `üîí Already locked: ${folderPath}`;

    const encryptedName = "._" + Math.random().toString(36).substring(2, 10);
    const encryptedPath = folderPath.replace(/\/$/, "").replace(/[^/]+$/, encryptedName);

    // Rename in filesystem
    fakeFileSystem[encryptedPath] = fakeFileSystem[folderPath];
    delete fakeFileSystem[folderPath];

    const parentPath = folderPath.split("/").slice(0, -1).join("/") || "/";
    const nameInParent = folderPath.split("/").pop();
    const encryptedInParent = encryptedPath.split("/").pop();

    const index = fakeFileSystem[parentPath].indexOf(nameInParent);
    if (index !== -1) fakeFileSystem[parentPath][index] = encryptedInParent;

    // Save mapping
    map[folderPath] = encryptedPath;
    localStorage.setItem("lockedFolderMap", JSON.stringify(map));
    saveFileSystem();

    return `üîê Folder "${folderPath}" has been locked and encrypted.`;
  }

  if (action === "unlock") {
    const encryptedPath = map[folderPath];
    if (!encryptedPath || !fakeFileSystem[encryptedPath]) {
      return `‚ùå Folder not locked or missing: ${folderPath}`;
    }

    const parentPath = folderPath.split("/").slice(0, -1).join("/") || "/";
    const normalName = folderPath.split("/").pop();
    const encryptedName = encryptedPath.split("/").pop();

    // Rename back
    fakeFileSystem[folderPath] = fakeFileSystem[encryptedPath];
    delete fakeFileSystem[encryptedPath];

    const index = fakeFileSystem[parentPath].indexOf(encryptedName);
    if (index !== -1) fakeFileSystem[parentPath][index] = normalName;

    delete map[folderPath];
    localStorage.setItem("lockedFolderMap", JSON.stringify(map));
    saveFileSystem();

    return `üîì Folder "${folderPath}" has been unlocked and restored.`;
  }

  return "‚ùå Usage: chmod lock|unlock /folderPath";
});


function parseOOS(raw) {
  const expanded = expandnebulaScript(raw);
  const blocks = [...expanded.matchAll(/(\w+)\s*\{([\s\S]*?)\}/g)];
  const objectMap = {};
  const app = {
    settings: { title: "OOS App", width: 600, height: 400, x: 100, y: 100, draggable: true },
    html: `<div style="position:relative; width:100%; height:100%; font-family:monospace;">`,
    interactions: []
  };

  // Step 1: parse all objects into raw map
  const rawObjects = {};
  blocks.forEach(([_, name, body]) => {
    rawObjects[name] = body.trim().split("\n");
  });

  // Step 2: resolve all base+variant merging
  for (const [name, lines] of Object.entries(rawObjects)) {
    const match = name.match(/^(\w+?)(\d+)$/);
    let mergedLines = [];

    if (match) {
      const base = match[1];
      const baseLines = rawObjects[base] || [];
      mergedLines = [...baseLines, ...lines];
    } else {
      mergedLines = lines;
    }

    const fields = { commands: [] };
    for (let line of mergedLines) {
      const [rawKey, ...rest] = line.split(":");
      if (!rawKey || rest.length === 0) continue;
      const key = rawKey.trim().toLowerCase();
      const value = rest.join(":").trim().replace(/^"|"$/g, "");

      if (key === "command") {
        fields.commands.push(value);
      } else {
        fields[key] = value;
      }
    }

    objectMap[name] = fields;
  }

  // Helper to run commands sequentially with delay
  function runCommandsSequentially(commands, delay) {
    let index = 0;
    function runNext() {
      if (index >= commands.length) return;
      handleCommand(commands[index]);
      index++;
      if (index < commands.length) {
        setTimeout(runNext, delay);
      }
    }
    runNext();
  }

  // Generate DOM + interactions
  for (const [name, fields] of Object.entries(objectMap)) {
    const dragx = fields.dragx !== undefined ? parseInt(fields.dragx) : null;
    const dragy = fields.dragy !== undefined ? parseInt(fields.dragy) : null;
    const x = dragx !== null ? dragx : parseInt(fields.x || "0");
    const y = dragy !== null ? dragy : parseInt(fields.y || "0");

    const type = fields.type;
    const styleBase = `position:absolute; left:${x}px; top:${y}px;`;
    const color = fields.textcolor || "white";
    const btnColor = fields.buttoncolor || "#00ff88";
    const shapeColor = fields.shapecolor || "#888";
    const delay = (parseInt(fields.delay) || 0) * 1000;

    if (type === "shape") {
      const width = fields.width || "60";
      const height = fields.height || "60";
      let shapeStyle = `width:${width}px; height:${height}px; background:${shapeColor}; ${styleBase}`;
      const shape = fields.shape || "rounded";
      shapeStyle += shape === "circle" ? "border-radius:50%;" :
                    shape === "pill" ? "border-radius:30px;" :
                    shape === "square" ? "border-radius:0;" :
                    "border-radius:5px;";
      app.html += `<div id="${name}" style="${shapeStyle}"></div>`;
    }

    if (type === "text") {
      const content = fields.content || "";
      const width = fields.width ? `width:${fields.width}px;` : "";
      const height = fields.height ? `height:${fields.height}px;` : "";
      app.html += `<p id="${name}" style="${styleBase} ${width} ${height} color:${color}; margin:0;">${content}</p>`;
    }

    if (type === "input") {
      const width = fields.width || "200";
      const height = fields.height || "30";
      const textColor = fields.textcolor || "#ffffff";
      const background = fields.inputcolor || "#111111"; // default black
      const border = fields.bordercolor || btnColor;

      app.html += `<textarea id="input_${name}" placeholder="${fields.placeholder || ""}" style="${styleBase} width:${width}px; height:${height}px; padding:6px; color:${textColor}; background:${background}; border:1px solid ${border}; resize:none; font-family:sans-serif; line-height:1.5; box-sizing:border-box;">${fields.content || ""}</textarea>`;
    }



    if (type === "button") {
      const btnId = `btn_${name}`;
      const label = fields.label || "Click";
      const inputBind = fields.inputbind ? `input_${fields.inputbind}` : null;
      const width = fields.width ? `width:${fields.width}px;` : "";
      const height = fields.height ? `height:${fields.height}px;` : "";

      app.html += `<button id="${btnId}" style="${styleBase} ${width} ${height} padding:6px 14px; background:${btnColor}; border:none; color:${color}; cursor:pointer;">${label}</button>`;

      app.interactions.push(doc => {
        const btn = doc.getElementById(btnId);
        const boundInput = inputBind ? doc.getElementById(inputBind) : null;
        if (!btn) return;

        btn.addEventListener("click", () => {
          let cmds = [...fields.commands];
          if (boundInput) {
            cmds = cmds.map(cmd => cmd.replace("INPUT", boundInput.value));
          }
          runCommandsSequentially(cmds, delay);
        });
      });
    }


    if (fields.interact && fields.interact.toLowerCase() === "true" && fields.commands.length > 0) {
      app.interactions.push(doc => {
        const el = doc.getElementById(name);
        if (el) {
          el.style.cursor = "pointer";
          el.addEventListener("click", () => {
            runCommandsSequentially(fields.commands, delay);
          });
        }
      });
    }

    if (fields.drag && fields.drag.toLowerCase() === "true") {
      app.interactions.push(doc => {
        const el = doc.getElementById(name);
        if (!el) return;

        let isDragging = false;
        let offsetX = 0;
        let offsetY = 0;
        const originalPos = { x, y };

        el.style.cursor = "grab";
        el.style.userSelect = "none";

        el.addEventListener("mousedown", e => {
          isDragging = true;
          offsetX = e.offsetX;
          offsetY = e.offsetY;
          el.style.cursor = "grabbing";
          el.style.zIndex = 999;
        });

        doc.addEventListener("mouseup", () => {
          if (!isDragging) return;
          isDragging = false;
          el.style.cursor = "grab";

          if (fields.drop && fields.drop.toLowerCase() === "true") {
            const elRect = el.getBoundingClientRect();

            for (const [targetName, targetFields] of Object.entries(objectMap)) {
              if (targetFields.target && targetFields.target.toLowerCase() === "true") {
                const targetEl = doc.getElementById(targetName);
                if (!targetEl) continue;

                const targetRect = targetEl.getBoundingClientRect();

                const overlap = !(
                  elRect.right < targetRect.left ||
                  elRect.left > targetRect.right ||
                  elRect.bottom < targetRect.top ||
                  elRect.top > targetRect.bottom
                );

                if (overlap && targetFields.commands?.length) {
                  runCommandsSequentially(targetFields.commands, (parseInt(targetFields.delay) || 0) * 1000);
                  break;
                }
              }
            }

            el.style.left = originalPos.x + "px";
            el.style.top = originalPos.y + "px";
          }
        });

        doc.addEventListener("mousemove", e => {
          if (!isDragging) return;

          const parentRect = el.parentElement.getBoundingClientRect();
          const newX = e.clientX - parentRect.left - offsetX;
          const newY = e.clientY - parentRect.top - offsetY;

          el.style.left = newX + "px";
          el.style.top = newY + "px";

          objectMap[name].dragx = newX;
          objectMap[name].dragy = newY;
        });
      });
    }
  }

  app.html += `</div>`;
  return app;
}

function expandnebulaScript(script) {
  const lines = script.split("\n");
  const variables = {};
  const blocks = {};
  let i = 0;

  // Step 1: extract variables
  for (const line of lines) {
    const match = line.trim().match(/^var(\w+)\s*=\s*(\d+)$/);
    if (match) variables[match[1]] = parseInt(match[2]);
  }

  const output = [];

  // Step 2: loop through and expand
  while (i < lines.length) {
    const line = lines[i].trim();
    const blockMatch = line.match(/^\$(\w+?)(\d*)\s*\{$/);

    if (blockMatch) {
      const [_, baseName, variantNum] = blockMatch;
      let blockLines = [];
      i++;
      while (i < lines.length && lines[i].trim() !== "}") {
        blockLines.push(lines[i]);
        i++;
      }
      i++;

      // Store blocks by name
      const blockKey = variantNum === "" ? `$${baseName}` : `$${baseName}${variantNum}`;
      blocks[blockKey] = blockLines;
    } else {
      output.push(lines[i]);
      i++;
    }
  }

  // Step 3: generate expanded output
  for (const [varName, count] of Object.entries(variables)) {
    const baseBlock = blocks[`$${varName}`] || [];

    for (let n = 0; n < count; n++) {
      const variantBlock = blocks[`$${varName}${n}`] || [];
      const combined = [...baseBlock, ...variantBlock];

      output.push(`${varName}${n} {`);
      for (let line of combined) {
        const replaced = line
          .replace(/\bauto\b/g, n)
          .replace(/(\d+)\s*\*\s*(\d+)/g, (_, a, b) => Number(a) * Number(b));
        output.push(replaced);
      }
      output.push("}");
    }
  }

  return output.join("\n");
}


registerCommand("openfinder", args => {
  const folderPath = args[0];

  if (!folderPath || !fakeFileSystem[folderPath]) {
    return "‚ùå Usage: openfinder /folder/path";
  }

  const finderCommand = `finder ${folderPath}`;
  handleCommand(finderCommand);

  return `üóÇÔ∏è Opening Finder at "${folderPath}"...`;
});

registerCommand("cleardir", args => {
  let targetPath = args[0] || currentDir;

  // Normalize path
  if (!targetPath.startsWith("/")) {
    targetPath = currentDir === "/" ? `/${targetPath}` : `${currentDir}/${targetPath}`;
  }
  targetPath = targetPath.replace(/\/+/g, "/");

  const contents = fakeFileSystem[targetPath];
  if (!Array.isArray(contents)) {
    return `‚ùå "${targetPath}" is not a valid directory.`;
  }

  const protectedFolders = ["apps", "dock", "desktop"];
  const isProtected = protectedFolders.includes(targetPath.split("/").pop());

  // Ask for confirmation if protected
  if (isProtected) {
    const passwordMap = JSON.parse(localStorage.getItem("userPasswords") || "{}");
    const expected = passwordMap[currentUser];

    if (!expected) {
      return "‚ùå You must set a user password to clear protected folders.";
    }

    const confirmation = prompt(`‚ö†Ô∏è Protected folder "${targetPath}". Enter your password to confirm:`);
    if (confirmation !== expected) {
      return "‚ùå Incorrect password. Action cancelled.";
    }
  }

  const removed = [];

  for (const item of [...contents]) {
    const itemPath = targetPath === "/" ? `/${item}` : `${targetPath}/${item}`;

    // Recursively clear folders
    if (fakeFileSystem[itemPath] && Array.isArray(fakeFileSystem[itemPath])) {
      fakeFileSystem[itemPath] = []; // empty the folder
    } else {
      // Remove file content
      localStorage.removeItem("fileContent:" + itemPath);

      // Remove app metadata
      const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
      delete appMeta[itemPath];
      localStorage.setItem("appFileMeta", JSON.stringify(appMeta));

      // Remove from app registry if linked
      const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
      for (const key in registry) {
        if (registry[key].file === itemPath) {
          delete registry[key];
        }
      }
      localStorage.setItem("appRegistry", JSON.stringify(registry));
    }

    removed.push(item);
  }

  fakeFileSystem[targetPath] = [];
  saveFileSystem();

  return `üßπ Cleared ${removed.length} item(s) from "${targetPath}".`;
});

registerCommand("pkg", () => {
  if (localStorage.getItem("intnixCodeUnlocked") !== "true") {
    handleCommand("intnixcode");
    return "üîê Intnix authorization required.";
  }


  return new Promise((resolve) => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".html,.oos";
    input.style.display = "none";
    document.body.appendChild(input);

    input.onchange = () => {
      const file = input.files[0];
      if (!file) {
        resolve("‚ùå No file selected.");
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        let name = prompt("App Name?");
        if (!name || !name.trim()) {
          resolve("‚ùå Cancelled. App name is required.");
          return;
        }

        name = name.trim();
        const icon = prompt("Icon URL or file (optional):") || "default.jpg";
        const description = prompt("Description?") || "No description";
        const version = prompt("Version?") || "1.0";

        const ext = file.name.split(".").pop().toLowerCase();
        const isOOS = ext === "oos";
        const content = reader.result;

        // ‚úÖ Preserve .oos files as .oos (no .app suffix)
        const pkgPath = isOOS
          ? `/pkgrepo/${name}.oos`
          : `/pkgrepo/${name}.app`;

        const pkgManifest = JSON.parse(localStorage.getItem("pkgManifest") || "{}");

        // Save content in localStorage as file
        localStorage.setItem("fileContent:" + pkgPath, content);

        // Save to manifest (now with file content too)
        pkgManifest[name] = {
          file: pkgPath,
          icon,
          description,
          version,
          type: ext,
          content // üëà This line adds the file content to the manifest
        };

        localStorage.setItem("pkgManifest", JSON.stringify(pkgManifest));
        resolve(`üì¶ Package "${name}" added as ${pkgPath}`);
      };

      reader.readAsText(file);
    };

    input.click();
  });
});

registerCommand("pkgmgr", async () => {
  try {
    const res = await fetch("pkgMan.json");
    const pkgManifest = await res.json();
    const entries = Object.entries(pkgManifest);

    if (entries.length === 0) {
      return "üì¶ No packages available.";
    }

    const lines = entries.map(([name, data]) => {
      return `üì¶ ${name} (v${data.version || "1.0"}) - ${data.description || "No description"}`;
    });

    return lines.join("\n");
  } catch (err) {
    return "‚ùå Failed to load pkgMan.json.";
  }
});


registerCommand("clearpkg", () => {
  const pkgManifest = JSON.parse(localStorage.getItem("pkgManifest") || "{}");

  // Remove each stored package file
  Object.values(pkgManifest).forEach(pkg => {
    const path = pkg.file;
    localStorage.removeItem("fileContent:" + path);
  });

  // Clear the manifest
  localStorage.removeItem("pkgManifest");

  // Optional: clear the /pkgrepo folder if it exists visually
  if (fakeFileSystem["/pkgrepo"]) {
    fakeFileSystem["/pkgrepo"] = [];
    saveFileSystem();
  }

  return "üßπ All packages cleared from repo.";
});
registerCommand("installpkg", async args => {
  const appName = args.join(" ").replace(/\"/g, "").trim();
  if (!appName) return '‚ùå Usage: installpkg "AppName"';

  let pkgManifest;
  try {
    const res = await fetch("pkgMan.json");
    pkgManifest = await res.json();
  } catch (e) {
    return "‚ùå Failed to load pkgMan.json.";
  }

  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");

  const pkg = pkgManifest[appName];
  if (!pkg) return `‚ùå Package "${appName}" not found in the package manifest.`;

  const content = pkg.content;
  if (!content) return `‚ùå Package "${appName}" has no content in manifest.`;

  const fileName = pkg.file.split("/").pop();
  const appPath = `/apps/${fileName}`;

  // Ensure /apps exists
  if (!fakeFileSystem["/apps"]) fakeFileSystem["/apps"] = [];

  if (!fakeFileSystem["/apps"].includes(fileName)) {
    fakeFileSystem["/apps"].push(fileName);
  }

  // Save file content
  localStorage.setItem("fileContent:" + appPath, content);

  // Add metadata
  appMeta[appPath] = {
    name: appName,
    icon: pkg.icon || "default.jpg",
    type: pkg.type || "html",
    description: pkg.description || "",
    version: pkg.version || "1.0",
    content
  };
  localStorage.setItem("appFileMeta", JSON.stringify(appMeta));

  registry[appName] = {
    file: appPath,
    icon: pkg.icon || "default.jpg"
  };
  localStorage.setItem("appRegistry", JSON.stringify(registry));

  saveFileSystem();
  return `‚úÖ Installed "${appName}" to /apps as ${fileName}`;
});

registerCommand("viewpkg", args => {
  const appName = args.join(" ").replace(/\"/g, "").trim();
  if (!appName) return '‚ùå Usage: viewpkg "PackageName"';

  const pkgManifest = JSON.parse(localStorage.getItem("pkgManifest") || "{}");
  const pkg = pkgManifest[appName];

  if (!pkg) return `‚ùå Package "${appName}" not found in package manifest.`;

  // Build readable info output
  const info = [
    `üì¶ Package: ${appName}`,
    `üßæ File: ${pkg.file}`,
    `üñºÔ∏è Icon: ${pkg.icon || "default.jpg"}`,
    `üìÑ Description: ${pkg.description || "N/A"}`,
    `üìå Version: ${pkg.version || "1.0"}`,
    `üß† Type: ${pkg.type || "html"}`,
    `\nüìú Content:\n${pkg.content || "// No content in manifest."}`
  ];

  return info.join("\n");
});



registerCommand("closeapp", () => {
  const windows = document.querySelectorAll(".window");
  windows.forEach(win => win.remove());

  // Clear tracked windows if you use openWindows[]
  if (typeof openWindows === "object") {
    for (const id in openWindows) {
      delete openWindows[id];
    }
  }

  return "‚ùå All windows closed.";
});// closewindow command
registerCommand("closewindow", () => {
  const allWindows = [...document.querySelectorAll(".window")];
  if (allWindows.length === 0) return "‚ùå No windows open.";

  // Find the topmost window (highest z-index)
  let topWindow = null;
  let highestZ = -1;

  for (const win of allWindows) {
    const z = parseInt(win.style.zIndex) || 0;
    if (z > highestZ) {
      highestZ = z;
      topWindow = win;
    }
  }

  if (!topWindow) return "‚ùå Couldn't find a window to close.";

  const winId = topWindow.id;
  topWindow.remove();
  if (openWindows[winId]) delete openWindows[winId];

  return `‚ùå Closed window ${winId}`;
});
registerCommand("launch", async (args) => {
  const input = args[0];
  if (!input) return "‚ùå Usage: launch AppName or /path/to/file.app";

  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
  const allPaths = Object.keys(appMeta);
  let fullPath = "";
  let fileName = "";

  if (input.startsWith("/")) {
    fullPath = input;
    fileName = input.split("/").pop();
  } else {
    const appName = input.replace(/\"/g, "").trim();
    const match = allPaths.find(path => {
      const base = path.split("/").pop().replace(/\.oos\.app$|\.nano\.app$|\.app$/i, "");
      return base === appName || path.endsWith("/" + appName);
    });

    if (match) {
      fullPath = match;
      fileName = match.split("/").pop();
    } else {
      return `‚ùå App "${appName}" not found in registry`;
    }
  }

  let content = localStorage.getItem("fileContent:" + fullPath);
  if (!content && appMeta[fullPath]?.content) {
    content = appMeta[fullPath].content;
  }

  if (!content) return `‚ùå No content found for ${fileName || fullPath}`;

  // üß† O++ app
  if (fileName.endsWith(".oos.app")) {
    try {
      const app = parseOOS(content);
      const id = createWindow();
      const iframe = document.getElementById(`${id}-content`);
      const doc = iframe.contentDocument || iframe.contentWindow.document;

      doc.body.innerHTML = app.html;
      app.interactions.forEach(fn => fn(doc));

      const win = iframe.parentElement;
      win.style.width = app.settings.width + "px";
      win.style.height = app.settings.height + "px";
      win.style.left = app.settings.x + "px";
      win.style.top = app.settings.y + "px";
      win.querySelector(".title-bar span").textContent = app.settings.title;

      return `üöÄ Launched ${app.settings.title}`;
    } catch (e) {
      return `‚ùå Failed to launch OOS app: ${e.message}`;
    }
  }

  // üìù .nano.app ‚Üí nano edit
  if (fileName.endsWith(".nano.app")) {
    const originalPath = fullPath.replace(/\.nano\.app$/, "");
    handleCommand(`nano "${originalPath}"`);
    return `‚úèÔ∏è Opened ${originalPath} in Nano`;
  }

  // üåê .app ‚Üí launch HTML content
  if (fileName.endsWith(".app")) {
    const winId = createWindow(fullPath);
    const iframe = document.getElementById(`${winId}-content`);
    iframe.srcdoc = content;
    return `üöÄ Launched ${fileName} as HTML`;
  }

  // üß† HTML content in raw files (htmlnano behavior)
  const isFullHTML = content.includes("<html") && content.includes("</html>");
  if (fileName.endsWith(".html") || isFullHTML) {
    const winId = createWindow(fullPath);
    const iframe = document.getElementById(`${winId}-content`);
    iframe.srcdoc = content;
    return `üöÄ HTML from "${fileName}" launched in window ${winId}`;
  }

  // ‚úèÔ∏è Default: open in nano if it's a text file
  handleCommand(`nano "${fileName}"`);
  return `‚úèÔ∏è Opened "${fileName}" in Nano`;
});registerCommand("launchtext", args => {
  const rawPath = args[0]?.replace(/^['\"]|['\"]$/g, "").trim();
  if (!rawPath || !rawPath.endsWith(".txt")) return "‚ùå Usage: launchtext file.txt";

  const fullPath = normalizePath(
    rawPath.startsWith("/") ? rawPath : `${currentDir}/${rawPath}`
  );

  const contentKey = "fileContent:" + fullPath;
  let content = localStorage.getItem(contentKey);

  if (content === null) {
    localStorage.setItem(contentKey, "");
    content = "";
  }

  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  const editorPath = "/apps/texteditor.app";
  const appContent = localStorage.getItem("fileContent:" + editorPath) || appMeta[editorPath]?.content;

  if (!appContent) return "‚ùå Texteditor.app not found or has no content.";

  const winId = createWindow(fullPath);
  const iframe = document.getElementById(`${winId}-content`);
  iframe.srcdoc = appContent;

  iframe.onload = () => {
    const editorDoc = iframe.contentDocument || iframe.contentWindow.document;

    const tryInject = setInterval(() => {
      const editor = editorDoc.getElementById("editor");
      if (editor) {
        editor.innerText = content;

        editor.addEventListener("input", () => {
          const updated = editor.innerText;
          localStorage.setItem(contentKey, updated);
        });

        clearInterval(tryInject);
      }
    }, 100);
  };

  return `üìù Editing "${fullPath}" in texteditor.app`;
});


registerCommand("deletepkg", (args) => {
  const user = localStorage.getItem("currentUser") || "admin";
  if (user !== "admin") return "‚ùå Only admin can delete packages.";

  const name = args[0];
  if (!name) return "‚ùå Usage: deletepkg AppName";

  const pkgManifest = JSON.parse(localStorage.getItem("pkgManifest") || "{}");
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");

  if (!pkgManifest[name]) {
    return `‚ùå Package "${name}" not found in pkg repo.`;
  }

  const filePath = pkgManifest[name].file;

  // üßπ Delete from fileContent and pkgManifest
  localStorage.removeItem("fileContent:" + filePath);
  delete pkgManifest[name];
  localStorage.setItem("pkgManifest", JSON.stringify(pkgManifest));

  // üßπ Delete from /apps in fakeFileSystem
  const appsFolder = fakeFileSystem["/apps"];
  if (Array.isArray(appsFolder)) {
    const fileName = filePath.split("/").pop();
    const index = appsFolder.indexOf(fileName);
    if (index !== -1) {
      appsFolder.splice(index, 1);
    }
  }

  // üßπ Delete from appFileMeta if present
  delete appMeta[filePath];
  localStorage.setItem("appFileMeta", JSON.stringify(appMeta));

  return `üóëÔ∏è Deleted package "${name}" from pkg repo and /apps`;
});
registerCommand("coder", async (args) => {
  const fileName = args[0];
  if (!fileName) return "‚ùå Usage: coder file.oos";

  const fullPath = fileName.startsWith("/")
    ? fileName
    : (currentDir === "/" ? `/${fileName}` : `${currentDir}/${fileName}`);

  const content = localStorage.getItem("fileContent:" + fullPath);
  if (!content) return `‚ùå File "${fileName}" not found.`;

  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
  const editorPath = "/apps/codetest.app";
  const appContent = localStorage.getItem("fileContent:" + editorPath) || appMeta[editorPath]?.content;
  if (!appContent) return "‚ùå codetest.app not found.";

  // ü™ü Create codetest window
  const winId = createWindow(fullPath);
  const iframe = document.getElementById(`${winId}-content`);
  const blob = new Blob([appContent], { type: "text/html" });
  iframe.src = URL.createObjectURL(blob);

  // ‚è≥ Wait 4 seconds, then inject content
  iframe.onload = () => {
    setTimeout(() => {
      iframe.contentWindow.postMessage({
        type: "loadFromLauncher",
        fileName: fileName,
        content: content
      }, "*");
    }, 100);
  };

  return `üì• Opening ${fileName} `;
});
registerCommand("repkg", () => {
  return new Promise((resolve) => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".html";
    input.style.display = "none";
    document.body.appendChild(input);

    input.onchange = () => {
      const file = input.files[0];
      if (!file) {
        resolve("‚ùå No file selected.");
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        const content = reader.result;
        const pkgManifest = JSON.parse(localStorage.getItem("pkgManifest") || {});
        const pkgNames = Object.keys(pkgManifest);

        if (pkgNames.length === 0) {
          resolve("üì¶ No packages found in the registry.");
          return;
        }

        // Show numbered list
        let list = "üì¶ Available Packages:\n";
        pkgNames.forEach((name, i) => {
          list += `${i + 1}. ${name}\n`;
        });
        alert(list);

        const num = prompt("Select package number to repackage:");
        const index = parseInt(num) - 1;

        if (isNaN(index) || index < 0 || index >= pkgNames.length) {
          resolve("‚ùå Invalid package number.");
          return;
        }

        const selectedName = pkgNames[index];
        const pkg = pkgManifest[selectedName];

        // Update package HTML content in pkg registry
        localStorage.setItem("fileContent:" + pkg.file, content);

        // Update all matching .app files across fakeFileSystem
        for (const dir in fakeFileSystem) {
          const files = fakeFileSystem[dir];
          if (!Array.isArray(files)) continue;

          files.forEach(file => {
            const baseName = file.replace(/\.oos\.app$|\.app$/, "");
            if (baseName === selectedName) {
              const fullPath = dir === "/" ? `/${file}` : `${dir}/${file}`;
              localStorage.setItem("fileContent:" + fullPath, content);
            }
          });
        }

        resolve(`üì¶ Repackaged and synced latest HTML for "${selectedName}".`);
      };

      reader.readAsText(file);
    };

    input.click();
  });
});

registerCommand("launchhtml", () => {
  return new Promise((resolve) => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".html";
    input.style.display = "none";
    document.body.appendChild(input);

    input.onchange = () => {
      const file = input.files[0];
      if (!file) {
        resolve("‚ùå No file selected.");
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        const content = reader.result;
        const fileName = file.name;

        const winId = createWindow(fileName);
        const iframe = document.getElementById(`${winId}-content`);
        iframe.srcdoc = content;

        resolve(`üöÄ Launched local HTML file: ${fileName}`);
      };

      reader.readAsText(file);
    };

    input.click();
  });
});

registerCommand("edit", args => {
  const filePath = args[0];
  if (!filePath) return '‚ùå Usage: edit /full/path/to/file.ext';

  const winId = createWindow(filePath); // ‚úÖ Pass filePath here
  const iframe = document.getElementById(`${winId}-content`);
  iframe.src = "Nebulacode.html"; // ‚úÖ Loads editor from file

  setTimeout(() => {
    iframe.contentWindow?.postMessage({
      type: "loadfile",
      path: filePath
    }, "*");
  }, 500); // Delay gives iframe time to load

  return `üìù Opening NebulaCode editor for ${filePath}`;
});

registerCommand("downloadpkg", () => {
  const user = localStorage.getItem("currentUser") || "admin";
  if (user !== "admin") {
    return "‚ùå Only admin can download package backups.";
  }

  const pkgManifest = localStorage.getItem("pkgManifest");
  if (!pkgManifest) {
    return "üì¶ No packages found.";
  }

  const blob = new Blob([pkgManifest], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const link = document.createElement("a");
  link.href = url;
  link.download = "pkgManifestBackup.json";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);

  return "üì• Package manifest backup downloaded.";
});

registerCommand("uploadpkg", () => {
  const user = localStorage.getItem("currentUser") || "admin";

  return new Promise((resolve) => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json";
    input.style.display = "none";
    document.body.appendChild(input);

    input.onchange = () => {
      const file = input.files[0];
      if (!file) {
        resolve("‚ùå No file selected.");
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        try {
          const cleaned = reader.result.replace(/^\uFEFF/, "");
          const manifest = JSON.parse(cleaned);

          if (typeof manifest !== "object" || Array.isArray(manifest)) {
            resolve("‚ùå Invalid package manifest format.");
            return;
          }

          // Save full manifest with types, icons, versions, etc.
          localStorage.setItem("pkgManifest", JSON.stringify(manifest));

          // Make sure /pkgrepo exists
          if (!fakeFileSystem["/pkgrepo"]) {
            fakeFileSystem["/pkgrepo"] = [];
          }

          for (const [pkgName, pkg] of Object.entries(manifest)) {
            const filePath = pkg.file;
            const fileName = filePath.split("/").pop();

            // Add to /pkgrepo visually
            if (!fakeFileSystem["/pkgrepo"].includes(fileName)) {
              fakeFileSystem["/pkgrepo"].push(fileName);
            }

            // Save actual file content from "content" field
            if (pkg.content) {
              localStorage.setItem("fileContent:" + filePath, pkg.content);
            }
          }

          saveFileSystem();
          resolve("üì¶ Packages uploaded, files registered, content saved.");
        } catch (err) {
          resolve("‚ùå Failed to parse package file: " + err.message);
        }
      };

      reader.readAsText(file);
    };

    input.click();
  });
});

function listOpenWindows() {
  return Object.keys(openWindows);
}

registerCommand("minimize", args => {
  const target = args[0];
  if (!target) return "‚ùå Usage: minimize [windowId or App Name]";

  let win = openWindows[target];
  let id = target;
  let filePath = null;

  // Try to find by app name if not a windowId
  if (!win) {
    const meta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
    const entry = Object.entries(meta).find(([_, data]) => data.name === target);
    if (entry) {
      filePath = entry[0]; // "/apps/Appstore.app"
      const fileName = filePath.split("/").pop().replace(/\W+/g, "_");
      id = `win_${fileName}`;
      win = openWindows[id];
    }
  }

  if (!win) return `‚ùå No open window found for "${target}"`;

  // Minimize the window
  win.style.display = "none";
  minimizedWindows[id] = win;

  // Add to dock folder in file system
  if (filePath) {
    const fileName = filePath.split("/").pop();
    const user = localStorage.getItem("currentUser") || "admin";
    const fsKey = `fileSystem:${user}`;
    const fs = JSON.parse(localStorage.getItem(fsKey) || "{}");

    fs["/dock"] = fs["/dock"] || [];
    if (!fs["/dock"].includes(fileName)) {
      fs["/dock"].push(fileName);
      localStorage.setItem(fsKey, JSON.stringify(fs));
    }
  }

  return `üóÇÔ∏è Window "${id}" minimized and added to dock.`;
});

registerCommand("returnmin", args => {
  const target = args[0];
  if (!target) return "‚ùå Usage: returnmin [App Name]";

  // Find the corresponding filePath from app name
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
  const entry = Object.entries(appMeta).find(([_, meta]) => meta.name === target);

  if (!entry) return `‚ùå App "${target}" not found in metadata`;

  const [filePath] = entry;
  const fileName = filePath.split("/").pop().replace(/\W+/g, "_");
  const winId = `win_${fileName}`;

  const win = minimizedWindows[winId];
  if (!win) return `‚ùå No minimized window found for "${target}"`;

  // Restore and bring to front
  win.style.display = "block";
  win.style.zIndex = zIndexCounter++;
  delete minimizedWindows[winId];

  return `üîº Restored "${target}" window`;
});

function returnmin(args) {
  const windowId = args[0];
  const win = minimizedWindows[windowId];
  if (!win) return;

  win.style.display = "block";
  delete minimizedWindows[windowId];

  // Remove from dock
  const user = localStorage.getItem("currentUser") || "admin";
  const fsKey = `fileSystem:${user}`;
  const fs = JSON.parse(localStorage.getItem(fsKey) || "{}");

  const fileName = windowId.replace("win_", "").replace(/_/g, "."); // or store filename directly
  fs["/dock"] = (fs["/dock"] || []).filter(name => !fileName.includes(name));
  localStorage.setItem(fsKey, JSON.stringify(fs));

  // Optional: tell dock iframe to rerender
  const dockFrame = document.querySelector("iframe#dock-frame");
  if (dockFrame) {
    dockFrame.contentWindow.postMessage({ type: "fs-data", fs, appMeta: JSON.parse(localStorage.getItem("appFileMeta") || "{}") }, "*");
  }
}

registerCommand("launchstart", () => {
  const key = `startupApps:${currentUser}`;
  const apps = JSON.parse(localStorage.getItem(key) || "[]");

  if (!apps.length) {
    return "üì≠ No startup apps or commands to launch.";
  }

  apps.forEach((entry, i) => {
    setTimeout(() => {
      if (entry.startsWith("run:")) {
        const cmd = entry.slice(4);
        try {
          handleCommand(cmd);
        } catch (err) {
          console.warn(`‚ùå Failed to run startup command: ${cmd}`, err);
        }
      } else {
        handleCommand(`launch ${entry}`);
      }
    }, i * 300); // Space them out a bit
  });

  return `üöÄ Launching ${apps.length} startup item(s)...`;
});
registerCommand("dockstate", () => {
  const raw = localStorage.getItem("dockState");
  if (!raw) return "‚ùå No saved dock state found.";

  try {
    const state = JSON.parse(raw);
    if (!state.type) return "‚ùå Saved dock state is invalid.";

    if (state.type === "sidedock" && state.side) {
      return handleCommand(`sidedock ${state.side}`);
    } else {
      return handleCommand(state.type);
    }
  } catch (e) {
    return "‚ö†Ô∏è Failed to parse dock state.";
  }
});

registerCommand("desktop", () => {
  setTimeout(() => {
    handleCommand("aerodock");
  }, 200);

  if (document.getElementById("desktop-window")) {
    return "üñ•Ô∏è Desktop is already open.";
  }

  // ‚úÖ Ensure taskbar exists (but don't add this window to it)
  if (!document.getElementById("taskbar")) {
    const taskbar = document.createElement("div");
    taskbar.id = "taskbar";
    taskbar.style.position = "fixed";
    taskbar.style.top = "-1px";
    taskbar.style.left = "325px";
    taskbar.style.width = "60%";
    taskbar.style.height = "20px";
    taskbar.style.background = "#1e1e1e;";
    taskbar.style.borderTop = "1px solid #111";
    taskbar.style.display = "flex";
    taskbar.style.alignItems = "center";
    taskbar.style.padding = "0 5px";
    taskbar.style.zIndex = "9999";
    taskbar.style.overflowX = "auto";
    document.body.appendChild(taskbar);
  }

  const iframeHTML = `
    <iframe src="file-explorer.html"
      style="width:100%; height:100%; border:none;"
      sandbox="allow-scripts allow-same-origin allow-downloads">
    </iframe>`;

  const win = document.createElement("div");
  win.className = "window";
  win.id = "desktop-window";
  Object.assign(win.style, {
    width: "calc(100vw + 1px)",
    height: "calc(100vh + 1px)",
    left: "-2px",
    top: "-2px",
    zIndex: "0",
    position: "fixed",
    margin: "0",
    padding: "0",
    borderRadius: "0",
    boxShadow: "none"
  });

  const content = document.createElement("div");
  content.className = "window-content";
  Object.assign(content.style, {
    padding: "0",
    width: "100%",
    height: "100%"
  });
  content.innerHTML = iframeHTML;

  const closeBtn = document.createElement("button");
  closeBtn.textContent = "‚úñ";
  Object.assign(closeBtn.style, {
    position: "absolute",
    top: "-50px",
    right: "80px",
    background: "rgba(0,0,0,0.6)",
    color: "#87CEEB",
    border: "1px solid #00000000",
    padding: "4px 8px",
    cursor: "pointer",
    zIndex: "10",
    borderRadius: "6px"
  });

  const tileBtn = document.createElement("button");
  tileBtn.textContent = "‚ñ¶";
  Object.assign(tileBtn.style, {
    position: "absolute",
    top: "2px",
    right: "90px",
    background: "rgba(0,0,0,0.6)",
    color: "#87CEEB",
    border: "2px",
    padding: "0px 0px",
    cursor: "pointer",
    zIndex: "10",
    borderRadius: "6px"
  });

  tileBtn.onclick = () => handleCommand("winmgr tile");

  win.appendChild(closeBtn);
  win.appendChild(tileBtn);
  win.appendChild(content);
  document.body.appendChild(win);

  // ‚úÖ Live updates for desktop file view
  const iframe = content.querySelector("iframe");
  let desktopRefreshInterval;

  iframe.onload = () => {
    const sendDesktopUpdate = () => {
      const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
      iframe.contentWindow.postMessage({
        type: "fs-data",
        fs: fakeFileSystem,
        appMeta,
        path: "/desktop"
      }, "*");
    };

    sendDesktopUpdate();
    desktopRefreshInterval = setInterval(sendDesktopUpdate, 1000);
  };



  // ‚úÖ Dock cleanup if needed
  window.addEventListener("message", (e) => {
    if (e.data.type === "app-closed" && e.data.name) {
      const wrapper = document.getElementById(`dock-wrapper-${e.data.name}`);
      if (wrapper) wrapper.classList.remove("active");
    }
  });


  handleCommand("launchstart");


  return `üñ•Ô∏è Desktop launched with live updates`;
});


registerCommand("closedesktop", () => {
  const desktopWin = document.getElementById("desktop-window");

  if (!desktopWin) {
    return "‚ùå No desktop window is open.";
  }

  // Remove the window from the DOM
  desktopWin.remove();

  // Clear the live update interval if it's running
  if (window.desktopRefreshInterval) {
    clearInterval(window.desktopRefreshInterval);
    window.desktopRefreshInterval = null;
  }

  return "üõë Desktop window closed.";
});


;

window.onload = () => {
  const rawBridge = localStorage.getItem("runbridge");
  if (rawBridge) {
    const commands = JSON.parse(rawBridge || "[]");
    if (commands.length && commands[0] === "runbridge") {
      // Automatically call runbridge command
      handleCommand("runbridge");
    }
  }

};
registerCommand("time", () => {
  return `üïí ${new Date().toLocaleTimeString()}`;
});

window.addEventListener("message", (event) => {
  if (event.data?.type === "focus-terminal") {
    // Try to bring the terminal to the front
    window.focus();

    // If terminal is inside a draggable window, boost z-index
    const terminalWin = document.getElementById("terminalWin"); // Replace with your actual terminal window ID
    if (terminalWin) {
      terminalWin.style.zIndex = (++zIndexCounter).toString();
    }

    // Optional: visually flash or focus
    const terminalEl = document.getElementById("terminal");
    if (terminalEl) {
      terminalEl.scrollIntoView({ behavior: "smooth" });
      terminalEl.style.outline = "2px solid #00ff88";
      setTimeout(() => terminalEl.style.outline = "none", 800);
    }
  }
});

registerCommand("windowterminal", () => {
  const termContainer = document.getElementById("terminal");

  if (document.getElementById("terminalWin")) {
    return "‚ö†Ô∏è Terminal is already in a window.";
  }

  const winId = "terminalWin";
  const win = document.createElement("div");
  win.className = "window";
  win.id = winId;

  Object.assign(win.style, {
    position: "absolute",
    left: "100px",
    top: "100px",
    width: "600px",
    height: "50%",
    resize: "both",
    overflow: "hidden",
    zIndex: (++zIndexCounter).toString(),
    minWidth: "300px",
    minHeight: "200px",
    borderRadius: "14px",
    backdropFilter: "blur(20px)",
    background: "rgba(255,255,255,0.05)",
    boxShadow: "0 20px 40px rgba(0,0,0,0.3)"
  });

  const titleBar = document.createElement("div");
  titleBar.className = "title-bar";
  titleBar.style.height = "32px";
  titleBar.style.padding = "6px 12px";
  titleBar.style.display = "flex";
  titleBar.style.alignItems = "center";
  titleBar.style.justifyContent = "space-between";
  titleBar.style.background = "rgba(255,255,255,0.08)";
  titleBar.style.borderBottom = "1px solid rgba(255,255,255,0.06)";
  titleBar.style.color = "#fff";
  titleBar.style.fontSize = "14px";
  titleBar.style.fontWeight = "500";

  titleBar.innerHTML = `
    <span style="flex:1; text-align:center;">Terminal</span>
    <div style="display:flex; gap:8px;">
      <button class="max-btn" style="width:14px;height:14px;border-radius:50%;background:#27c93f;border:none;cursor:pointer;">+</button>
      <button class="close-btn" style="width:14px;height:14px;border-radius:50%;background:#ff5f56;border:none;cursor:pointer;">√ó</button>
    </div>
  `;

  const content = document.createElement("div");
  content.className = "window-content";
  Object.assign(content.style, {
    height: "90%",
    width: "100%",
    overflow: "auto",
    background: "#1e1e1e"
  });
  content.appendChild(termContainer);

  win.appendChild(titleBar);
  win.appendChild(content);
  document.body.appendChild(win);

  openWindows[winId] = win;

  // Add to taskbar
  if (!document.getElementById("taskbar-btn-" + winId)) {
    const taskBtn = document.createElement("button");
    taskBtn.id = "taskbar-btn-" + winId;
    taskBtn.textContent = "Terminal";
    taskBtn.style.margin = "0 4px";
    taskBtn.style.padding = "1px 10px";
    taskBtn.style.background = "#444";
    taskBtn.style.color = "#fff";
    taskBtn.style.border = "0px solid #000";
    taskBtn.style.borderRadius = "3px";
    taskBtn.style.cursor = "pointer";

    taskBtn.onclick = () => {
      win.style.display = win.style.display === "none" ? "block" : "none";
      win.style.zIndex = (++zIndexCounter).toString();
    };

    document.getElementById("taskbar").appendChild(taskBtn);
  }

  // Maximize
  let isMaximized = false;
  let prevStyles = {};
  titleBar.querySelector(".max-btn").onclick = () => {
    if (!isMaximized) {
      prevStyles = {
        left: win.style.left,
        top: win.style.top,
        width: win.style.width,
        height: win.style.height
      };
      Object.assign(win.style, {
        position: "fixed",
        left: "5vw",
        top: "5vh",
        width: "90vw",
        height: "90vh"
      });
      isMaximized = true;
    } else {
      Object.assign(win.style, {
        position: "absolute",
        ...prevStyles
      });
      isMaximized = false;
    }
  };

  // Close
  titleBar.querySelector(".close-btn").onclick = () => {
    win.remove();
    const originalSlot = document.getElementById("terminal-original") || document.body;
    originalSlot.appendChild(termContainer);
    termContainer.style.position = "";
    termContainer.style.zIndex = "";

    const taskBtn = document.getElementById("taskbar-btn-" + winId);
    if (taskBtn) taskBtn.remove();
  };

  // Dragging
  let isDragging = false, offsetX = 0, offsetY = 0;
  titleBar.addEventListener("mousedown", e => {
    isDragging = true;
    offsetX = e.clientX - win.offsetLeft;
    offsetY = e.clientY - win.offsetTop;
    win.style.zIndex = (++zIndexCounter).toString();
  });

  document.addEventListener("mousemove", e => {
    if (isDragging) {
      win.style.left = `${e.clientX - offsetX}px`;
      win.style.top = `${e.clientY - offsetY}px`;
    }
  });

  document.addEventListener("mouseup", () => {
    isDragging = false;
  });

  return "ü™ü Terminal moved to window mode.";
});



registerCommand("sendmessage", args => {
  const recipient = args[0];
  const message = args.slice(1).join(" ");

  if (!recipient || !message) {
    return "‚ùå Usage: sendmessage [username] [message]";
  }

  const allMessages = JSON.parse(localStorage.getItem("userMessages") || "{}");

  if (!allMessages[recipient]) {
    allMessages[recipient] = [];
  }

  allMessages[recipient].push({ from: currentUser, message });
  localStorage.setItem("userMessages", JSON.stringify(allMessages));

  return `üì® Message sent to ${recipient}: "${message}"`;
});

registerCommand("getmessages", () => {
  const allMessages = JSON.parse(localStorage.getItem("userMessages") || "{}");
  const messages = allMessages[currentUser] || [];

  if (!messages.length) {
    return "üì≠ No new messages.";
  }

  const output = messages.map((m, i) => `(${i + 1}) From ${m.from}: ${m.message}`).join("\n");

  return `üì¨ Inbox for ${currentUser}:\n${output}`;
});

registerCommand("openwindows", () => {
  const stored = JSON.parse(localStorage.getItem("windowTracker") || "[]");
  if (!stored.length) return "ü™ü No windows opened yet.";

  return stored
    .map(w => `ü™ü ${w.name} ‚Äî ${w.path} @ ${w.time}`)
    .join("\n");
});
function sendGiveWindow(name) {
  const wrapper = document.getElementById(`dock-wrapper-${name}`);
  if (wrapper) {
    wrapper.classList.add("active"); // ‚úÖ show the white dot
  }
}

const winmgrOriginalStyles = {}; // Holds original positions/sizes by window ID
registerCommand("winmgr", args => {
  const mode = args[0];
  const windows = [...document.querySelectorAll(".window")].filter(win => win.id !== "desktop-window");
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;
  const winmgrOriginalStyles = {};

  if (!mode || mode === "list") {
    if (!windows.length) return "üì≠ No open windows.";
    return windows.map((win, i) => {
      const title = win.querySelector(".title-bar span")?.textContent || "Unnamed";
      return `#${i + 1} ‚Ä¢ ID: ${win.id} ‚Ä¢ Title: ${title} ‚Ä¢ Z: ${win.style.zIndex}`;
    }).join("\n");
  }

  if (mode === "tile") {
    const cols = Math.ceil(Math.sqrt(windows.length));
    const rows = Math.ceil(windows.length / cols);
    const w = Math.floor(screenWidth / cols);
    const h = Math.floor(screenHeight / rows);

    windows.forEach((win, i) => {
      winmgrOriginalStyles[win.id] = {
        left: win.style.left,
        top: win.style.top,
        width: win.style.width,
        height: win.style.height
      };

      const x = i % cols;
      const y = Math.floor(i / cols);

      Object.assign(win.style, {
        position: "absolute",
        width: `${w}px`,
        height: `${h - 70}px`,
        left: `${x * w}px`,
        top: `${y * h + 25}px`
      });
    });

    return `üî≤ Tiled ${windows.length} windows (desktop excluded).`;
  }



  if (mode === "stop") {
    windows.forEach(win => {
      const saved = winmgrOriginalStyles[win.id];
      if (saved) {
        Object.assign(win.style, saved);
      }
    });

    return "üõë Window Manager stopped. All windows restored.";
  }

  if (mode === "close") {
    const id = args[1];
    const win = document.getElementById(id);
    if (!win || win.id === "desktop-window") return `‚ùå Invalid window ID "${id}"`;
    win.remove();
    return `üóëÔ∏è Closed window "${id}"`;
  }

  return `üõ†Ô∏è winmgr usage:
  winmgr                 ‚Äî list all windows
  winmgr tile            ‚Äî auto-tile all open windows (excludes desktop)
  winmgr cascade         ‚Äî arrange windows in a cascade
  winmgr stop            ‚Äî restore original sizes/positions
  winmgr close [id]      ‚Äî close a window by ID
  `;
});

registerCommand("version", () => {
  let scriptLines = 0;

  // Count all <script> tag content line breaks
  document.querySelectorAll("script").forEach(script => {
    if (script.innerText) {
      scriptLines += script.innerText.split("\n").length;
    }
  });

  return `üß† Intnix Terminal (Webkernel)
üåå Version: 1.04
üìÖ Build: April 16, 2025
üìè Codebase: ${scriptLines.toLocaleString()} lines of JavaScript
üåê Distribution: NebulaOS
üá®üá¶üá®üá¶üá®üá¶ Made in Toronto, Ontario, Canada üá®üá¶üá®üá¶üá®üá¶`;
});


registerCommand("whoami", () => {
  return currentUser || "No user signed in";
});



registerCommand("deleteaptregistry", () => {
  const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");
  const pkgList = [
    "Nebula", "Appstore", "MP4", "Terminal", "cssdraw",
    "PDF", "PDFOCR", "PDFextract", "messages", "game", "texteditor"
  ]; // Pulled from your `pkgmgr` output

  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
  let deleted = 0;

  for (const [name, info] of Object.entries(registry)) {
    if (!pkgList.includes(name)) {
      delete registry[name];
      delete appMeta[info.file];
      deleted++;
    }
  }

  localStorage.setItem("appRegistry", JSON.stringify(registry));
  localStorage.setItem("appFileMeta", JSON.stringify(appMeta));

  return deleted
    ? `üóëÔ∏è Deleted ${deleted} apt-installed/unlicensed apps from registry.`
    : "‚úÖ No unlicensed apps found in registry.";
});

registerCommand("newline", () => {
  createInputLine();
  return "";
});






registerCommand("amendstart", args => {
  const entry = args.join(" ").trim();
  if (!entry) return "‚ùå Usage: amendstart [appname.app | run:command]";

  const key = `startupApps:${currentUser}`;
  const list = JSON.parse(localStorage.getItem(key) || "[]");

  if (!list.includes(entry)) {
    list.push(entry);
    localStorage.setItem(key, JSON.stringify(list));
    return `‚úÖ Added to startup: ${entry}`;
  } else {
    return `‚ö†Ô∏è ${entry} is already in startup items.`;
  }
});


registerCommand("viewstart", () => {
  const key = `startupApps:${currentUser}`;
  const list = JSON.parse(localStorage.getItem(key) || "[]");

  return list.length
    ? `üöÄ Startup Apps:\n${list.map(a => `‚Ä¢ ${a}`).join("\n")}`
    : "üì≠ No startup apps set.";
});

registerCommand("deletestart", () => {
  const key = `startupApps:${currentUser}`;
  const list = JSON.parse(localStorage.getItem(key) || "[]");

  if (list.length === 0) {
    return "üö´ No startup apps found.";
  }

  // Show list
  const listDiv = document.createElement("div");
  listDiv.style.fontFamily = "monospace";
  listDiv.style.marginTop = "6px";
  listDiv.style.color = "#0ff";

  listDiv.innerHTML = `<b>Startup Apps:</b><br>` + list.map((app, i) => ` ${i + 1}. ${app}`).join("<br>");
  terminal.appendChild(listDiv);

  // Prompt user
  const inputDiv = document.createElement("div");
  inputDiv.style.marginTop = "6px";
  inputDiv.textContent = "üóëÔ∏è delete program: ";
  inputDiv.style.fontFamily = "monospace";
  terminal.appendChild(inputDiv);

  const input = document.createElement("input");
  input.type = "text";
  input.style.background = "#000";
  input.style.color = "#0f0";
  input.style.border = "none";
  input.style.fontFamily = "monospace";
  input.style.outline = "none";
  inputDiv.appendChild(input);
  input.focus();

  input.addEventListener("keydown", e => {
    if (e.key === "Enter") {
      const index = parseInt(input.value) - 1;
      if (isNaN(index) || index < 0 || index >= list.length) {
        inputDiv.textContent = "‚ùå Invalid selection.";
        return;
      }

      const toRemove = list[index];
      list.splice(index, 1);
      localStorage.setItem(key, JSON.stringify(list));

      inputDiv.textContent = `‚úÖ Removed "${toRemove}" from startup list.`;
    }
  });

  terminal.scrollTop = terminal.scrollHeight;
  return "";
});



let sharedWebWindow = null;


registerCommand("webpage", args => {
  const site = args[0];
  if (!site) return "‚ùå Usage: webpage [site]";

  const url = site.includes(".") ? `https://${site}` : `https://${site}.com`;

  // Open directly in external Chrome window
  window.open(
    url,
    "nebulaWeb",
    "width=1000,height=700,left=200,top=100,menubar=no,toolbar=no,location=no,status=no,resizable=yes"
  );

  return `üåê Launched ${url} in external browser window.`;
});



registerCommand("fullscreen", () => {
  const elem = document.documentElement;

  if (!document.fullscreenElement) {
    elem.requestFullscreen().catch(err => {
      console.log("Fullscreen error:", err);
    });
    return "üñ•Ô∏è Entered full-screen mode.";
  } else {
    document.exitFullscreen();
    return "üö™ Exited full-screen mode.";
  }
});


registerCommand("exitfullscreen", () => {
  // Try to exit programmatic fullscreen
  document.exitFullscreen?.().catch(() => {});

  // If in F11 fullscreen mode
  if (window._f11BinaryState === 1) {
    return "‚ö†Ô∏è You're in F11 fullscreen mode. Please press F11 again to exit.";
  }

  return "Press F11 to exit fullscreen.";
});

registerCommand("goto", args => {
  const site = args[0];
  if (!site) return "‚ùå Usage: goto [site]";

  const url = site.includes(".") ? `https://${site}` : `https://${site}.com`;

  // Redirect current tab
  window.location.href = url;

  return `üåê Redirecting to ${url}...`;
});



registerCommand("home", () => {

    handleCommand("cd /");
      handleCommand("clear");

});

registerCommand("updatesys", () => {
  // Retrieve the package manifest and the installed app registry from localStorage.
  const pkgManifest = JSON.parse(localStorage.getItem("pkgManifest") || "{}");
  const registry = JSON.parse(localStorage.getItem("appRegistry") || "{}");

  let updatedApps = [];
  let noUpdates = [];
  let notFound = [];

  // Loop through each installed app.
  Object.keys(registry).forEach(appName => {
    if (pkgManifest[appName]) {
      // Compare versions.
      if (registry[appName].version !== pkgManifest[appName].version) {
        // Update the installed version to the new version from the manifest.
        registry[appName].version = pkgManifest[appName].version;
        updatedApps.push(appName);
      } else {
        // App is up-to-date.
        noUpdates.push(appName);
      }
    } else {
      // App not found in package manifest.
      notFound.push(appName);
    }
  });

  // Save the updated registry back to localStorage.
  localStorage.setItem("appRegistry", JSON.stringify(registry));

  // Build an output message.
  let output = "Updates completed:\n";

  if (updatedApps.length > 0) {
    updatedApps.forEach(app =>
      output += `- ${app}: updated to version ${pkgManifest[app].version}\n`
    );
  } else {
    output += "- No apps needed updating.\n";
  }

  if (notFound.length > 0) {
    output += "The following apps were not found in the appstore manifest and were skipped:\n";
    notFound.forEach(app => output += `- ${app}\n`);
  }

  return output;
});

registerCommand("scan", () => {

  const currentUser = localStorage.getItem("currentUser");
if (currentUser !== "admin") {
  return "‚õî This command is admin-only.";
}
  const viewingUser = window.viewingUser || null;
  const userKey = viewingUser || currentUser;

  const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
  const userFS = allUsers[userKey] || {};

  const fileSystemPaths = new Set();
  const memoryPaths = new Set(
    Object.keys(localStorage)
      .filter(k => k.startsWith("fileContent:"))
      .map(k => k.slice(12))
      .filter(path => path.startsWith("/")) // Ignore broken keys
  );

  // Traverse only this user's file system
  for (const [folder, items] of Object.entries(userFS)) {
    if (Array.isArray(items)) {
      for (const item of items) {
        const fullPath = folder === "/" ? `/${item}` : `${folder}/${item}`;
        fileSystemPaths.add(fullPath);
      }
    }
  }

  const allPaths = new Set([...fileSystemPaths, ...memoryPaths]);
  const sorted = [...allPaths].sort();
  const output = [];

  output.push(`üìÇ FILE SYSTEM (${userKey})`.padEnd(35) + "üß† MEMORY");
  output.push("‚îÄ".repeat(70));

  const redundantList = [];

  sorted.forEach(path => {
    const inFS = fileSystemPaths.has(path);
    const inMem = memoryPaths.has(path);

    const fsColumn = inFS ? `‚úÖ ${path}` : "‚ùå".padEnd(35);
    const memColumn = inMem ? `‚úÖ ${path}` : "‚ùå";

    output.push(fsColumn.padEnd(35) + memColumn);

    if (inMem && !inFS) {
      redundantList.push({ type: "memory", path });
    } else if (inFS && !inMem) {
      redundantList.push({ type: "filesystem", path });
    }
  });

  const terminalOutput = document.createElement("div");
  terminalOutput.innerText = output.join("\n");
  terminal.appendChild(terminalOutput);

  const confirmPrompt = document.createElement("div");
  confirmPrompt.innerHTML = `\nüóëÔ∏è <span style="color:orange">Start deleting redundant files one-by-one? (y/n)</span> `;

  const input = document.createElement("input");
  input.type = "text";
  input.className = "cmd-input";
  input.style.color = "#ff5555";
  input.style.border = "none";
  input.style.background = "transparent";
  input.autofocus = true;

  confirmPrompt.appendChild(input);
  terminal.appendChild(confirmPrompt);
  input.focus();

  input.addEventListener("keydown", function (e) {
    if (e.key.toLowerCase() === "y") {
      input.disabled = true;
      runInteractiveDelete(redundantList.slice(), userKey); // scoped cleanup
    } else if (e.key.toLowerCase() === "n") {
      terminal.appendChild(document.createElement("div")).textContent = "‚ùé No files deleted.";
      input.disabled = true;
    }
  });

  return "";
});

function runInteractiveDelete(queue, userKey) {
  if (queue.length === 0) {
    saveFileSystem();
    terminal.appendChild(document.createElement("div")).textContent = "‚úÖ Cleanup complete.";
    return;
  }

  const current = queue.shift();
  const promptLine = document.createElement("div");
  promptLine.innerHTML = `üóëÔ∏è Delete <span style="color:cyan">${current.path}</span> from <b>${current.type}</b>? (y/n) `;

  const input = document.createElement("input");
  input.type = "text";
  input.className = "cmd-input";
  input.style.color = "#ff5555";
  input.style.border = "none";
  input.style.background = "transparent";
  input.autofocus = true;

  promptLine.appendChild(input);
  terminal.appendChild(promptLine);
  input.focus();

  input.addEventListener("keydown", function (e) {
    const ans = e.key.toLowerCase();
    if (ans === "y") {
      if (current.type === "memory") {
        localStorage.removeItem("fileContent:" + current.path);
      } else if (current.type === "filesystem") {
        const folder = current.path.substring(0, current.path.lastIndexOf("/")) || "/";
        const name = current.path.split("/").pop();
        const allUsers = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
        const userFS = allUsers[userKey];
        if (userFS && userFS[folder]) {
          userFS[folder] = userFS[folder].filter(f => f !== name);
        }
        localStorage.setItem("userFileSystems", JSON.stringify(allUsers));
      }
      input.disabled = true;
      runInteractiveDelete(queue, userKey);
    } else if (ans === "n") {
      input.disabled = true;
      runInteractiveDelete(queue, userKey);
    }
  });
}

registerCommand("cleanup", () => {
  const preserveRoots = ["/apps", "/dock", "/desktop", "/documents"];

  const fileSystemPaths = new Set();
  const memoryPaths = new Set(
    Object.keys(localStorage)
      .filter(k => k.startsWith("fileContent:"))
      .map(k => k.slice(12))
  );

  // All file system entries
  for (const [folder, items] of Object.entries(fakeFileSystem)) {
    if (Array.isArray(items)) {
      for (const item of items) {
        const fullPath = folder === "/" ? `/${item}` : `${folder}/${item}`;
        fileSystemPaths.add(fullPath);
      }
    }
  }

  // Determine memory-only and file-only
  const memoryOnly = [...memoryPaths].filter(
    path => !fileSystemPaths.has(path) && !preserveRoots.some(root => path.startsWith(root))
  );

  const fileOnly = [...fileSystemPaths].filter(
    path => !memoryPaths.has(path) && !preserveRoots.some(root => path.startsWith(root))
  );

  let deletedMemory = 0;
  let deletedFiles = 0;

  // üß† Delete memory-only
  memoryOnly.forEach(path => {
    localStorage.removeItem("fileContent:" + path);
    deletedMemory++;
  });

  // üóÇÔ∏è Delete file-system-only
  fileOnly.forEach(path => {
    const folder = path.substring(0, path.lastIndexOf("/")) || "/";
    const name = path.split("/").pop();
    if (fakeFileSystem[folder]) {
      fakeFileSystem[folder] = fakeFileSystem[folder].filter(f => f !== name);
      deletedFiles++;
    }
  });

  saveFileSystem();

  return `üßπ Cleanup complete.\nüß† Removed ${deletedMemory} memory-only file(s).\nüìÅ Removed ${deletedFiles} file-system-only entry(ies).\nüö´ Preserved contents of: ${preserveRoots.join(", ")}`;
});

registerCommand("topcolor", args => {
  const input = args[0];
  const defaultColor = "#3a7bd580";

  if (!input) return "‚ùå Usage: topcolor [color] or topcolor reset";

  if (input.toLowerCase() === "reset") {
    document.documentElement.style.setProperty('--topbar-color', defaultColor);
    return `üîÑ Title bar color reset to default (${defaultColor})`;
  }

  document.documentElement.style.setProperty('--topbar-color', input);
  return `üé® Title bar color changed to ${input}`;
});

registerCommand("dockpos", args => {
  const side = args[0]?.toLowerCase();
  if (!side) return "‚ùå Usage: dockpos [left | right | reset]";

  if (!["left", "right", "reset"].includes(side)) {
    return "‚ùå Invalid option. Use: left, right, or reset.";
  }

  const target = side === "reset" ? "right" : side;
  localStorage.setItem("dockSide", target);

  // Notify dock
  window.postMessage({ type: "dock-side-update", value: target }, "*");

  // Trigger refresh (calls your existing "refresh" command)
  setTimeout(() => {
    handleCommand("closedesktop");
    handleCommand("desktop");
  }, 500); // Short delay before reload to ensure message is received

  return `üìç Dock position set to ${target} ‚Äî refreshing...`;
});

registerCommand("dockvis", args => {
  const action = args[0]?.toLowerCase() || "toggle";
  const dockStateKey = "dockHidden";
  let dockHidden = localStorage.getItem(dockStateKey) === "true";

  if (action === "show") {
    localStorage.setItem(dockStateKey, "false");
    window.postMessage({ type: "dock-visibility", value: "show" }, "*");

    setTimeout(() => {
      handleCommand("closedesktop");
      handleCommand("desktop");
    }, 500); // Sho
    return "üìÇ Dock is now visible.";
  }

  if (action === "hide") {
    localStorage.setItem(dockStateKey, "true");
    window.postMessage({ type: "dock-visibility", value: "hide" }, "*");

    setTimeout(() => {
      handleCommand("closedesktop");
      handleCommand("desktop");
    }, 500); // Sho
    return "üìÅ Dock has been hidden.";
  }

  // Toggle if no action provided
  dockHidden = !dockHidden;
  localStorage.setItem(dockStateKey, dockHidden.toString());
  window.postMessage({ type: "dock-visibility", value: dockHidden ? "hide" : "show" }, "*");

  setTimeout(() => {
    handleCommand("closedesktop");
    handleCommand("desktop");
  }, 500); // Sho
  return `ü™Ñ Dock toggled ${dockHidden ? "off" : "on"}.`;
});

registerCommand("savewindows", () => {
  const saved = [];
  const windows = document.querySelectorAll(".window");

  windows.forEach(win => {
    const iframe = win.querySelector("iframe");
    const file = iframe?.getAttribute("data-path");
    if (!file) return; // skip windows not tied to a file

    saved.push({
      file,
      left: win.style.left || "100px",
      top: win.style.top || "100px",
      width: win.style.width || "800px",
      height: win.style.height || "600px",
      zIndex: win.style.zIndex || "100",
    });
  });

  localStorage.setItem("savedWindowsRegistry", JSON.stringify(saved));
  return `üìù Saved ${saved.length} open window(s) to savedWindowsRegistry.`;
});

registerCommand("loadwindows", () => {
  const saved = JSON.parse(localStorage.getItem("savedWindowsRegistry") || "[]");
  if (!saved.length) return "üì≠ No saved windows to load.";

  saved.forEach(w => {
    const win = createWindow(w.file); // Assumes you have a function that opens windows by file path
    const el = document.getElementById(win); // The window ID returned from createWindow
    if (el) {
      el.style.left = w.left;
      el.style.top = w.top;
      el.style.width = w.width;
      el.style.height = w.height;
      el.style.zIndex = w.zIndex;
    }
  });

  // Clear the registry after restoring
  localStorage.removeItem("savedWindowsRegistry");

  return `üîÅ Loaded ${saved.length} window(s) from registry and cleared the saved layout.`;
});

registerCommand("commands", () => {
  const scripts = Array.from(document.scripts);
  const commandNames = new Set();

  const regex = /registerCommand\s*\(\s*["'`](.*?)["'`]/g;

  scripts.forEach(script => {
    const content = script.textContent;
    let match;
    while ((match = regex.exec(content)) !== null) {
      commandNames.add(match[1]);
    }
  });

  const list = Array.from(commandNames).sort();

  let output = "";
  let currentLetter = "";
  let counter = 1;

  list.forEach(cmd => {
    const first = cmd[0].toUpperCase();
    if (first !== currentLetter) {
      currentLetter = first;
      output += `\n\n${currentLetter} -----------\n`;
    }
    output += `${counter++}. ${cmd}\n`;
  });

  return `üß† Found ${list.length} registered commands:\n${output}`;
});


registerCommand("donut", () => {
  const output = document.createElement("pre");
  output.style.fontFamily = "monospace";
  output.style.lineHeight = "90%";
  output.style.fontSize = "11px";
  output.style.marginTop = "10px";
  output.style.whiteSpace = "pre";
  terminal.appendChild(output);

  let A = 1, B = 1;
  const width = 60;
  const height = 24;
  const chars = ".,-~:;=!*#$@";
  let hue = 0;

  const drawFrame = () => {
    const b = Array(width * height).fill(" ");
    const z = Array(width * height).fill(0);

    for (let j = 0; j < 6.28; j += 0.07) {
      for (let i = 0; i < 6.28; i += 0.02) {
        const c = Math.sin(i), l = Math.cos(i);
        const d = Math.cos(j), f = Math.sin(j);
        const g = Math.cos(A), e = Math.sin(A);
        const h = d + 2;
        const D = 1 / (c * h * e + f * g + 5);
        const m = Math.cos(B), n = Math.sin(B);
        const t = c * h * g - f * e;

        const x = Math.floor(width / 2 + 30 * D * (l * h * m - t * n));
        const y = Math.floor(height / 2 + 15 * D * (l * h * n + t * m));
        const o = x + width * y;
        const N = Math.floor(8 * ((f * e - c * d * g) * m - c * d * e - f * g - l * d * n));

        if (y >= 0 && y < height && x >= 0 && x < width && D > z[o]) {
          z[o] = D;
          b[o] = chars[Math.max(0, N)];
        }
      }
    }

    let frame = "";
    for (let i = 0; i < b.length; i++) {
      frame += b[i];
      if ((i + 1) % width === 0) frame += "\n";
    }

    output.innerText = frame;
    output.style.color = `hsl(${hue}, 100%, 70%)`;
    hue = (hue + 5) % 360;

    A += 0.07;
    B += 0.03;
  };

  const interval = setInterval(drawFrame, 100); // 10 FPS to stay performant
  window._donutInterval = interval;

handleCommand("loginchime")
  return "";
});


registerCommand("stopdonut", () => {
  clearInterval(window._donutInterval);
  handleCommand("stopmusic");
  return "üõë Donut stopped.";
});

(function trackF11BinaryToConsole() {
  let lastState = null;

  function checkF11State() {
    const isFullscreen = window.innerHeight >= screen.height - 1; // allow off-by-one
    const binary = isFullscreen ? 1 : 0;

    if (binary !== lastState) {
      console.log("F11 Binary State:", binary);
      lastState = binary;
    }
  }

  // Trigger on F11 transitions (resize works reliably)
  window.addEventListener("resize", () => {
    setTimeout(checkF11State, 100); // delay to let F11 resize finish
  });

  // Initial check
  setTimeout(checkF11State, 100);
})();



window._consoleLogHistory = [];



registerCommand("console", () => {
  const logs = window._consoleLogHistory || [];

  if (logs.length === 0) return "üì≠ Console log is empty.";

  logs.forEach(log => {
    const div = document.createElement("div");
    div.textContent = log.message;

    switch (log.type) {
      case "log":
        div.style.color = "#0f0";
        break;
      case "warn":
        div.style.color = "#ff0";
        break;
      case "error":
        div.style.color = "#f55";
        break;
      case "info":
        div.style.color = "#0af";
        break;
    }

    div.style.fontFamily = "monospace";
    terminal.appendChild(div);
  });

  terminal.scrollTop = terminal.scrollHeight;
  return "üßæ Dumped console logs to terminal.";
});

registerCommand("console-clear", () => {
  window._consoleLogHistory = [];
  return "üßπ Console log cleared.";
});

registerCommand("console-last", (args) => {
  const count = parseInt(args[0]) || 10;
  const logs = window._consoleLogHistory?.slice(-count) || [];

  if (logs.length === 0) return "üì≠ No recent logs.";

  logs.forEach(({ type, message }) => {
    const line = document.createElement("div");
    line.textContent = message;
    line.style.fontFamily = "monospace";
    line.style.color = type === "error" ? "#f55" :
                       type === "warn" ? "#ff0" :
                       type === "info" ? "#0af" : "#0f0";
    terminal.appendChild(line);
  });

  terminal.scrollTop = terminal.scrollHeight;
  return `üì• Showing last ${logs.length} console messages.`;
});

registerCommand("console-filter", (args) => {
  const type = args[0];
  const validTypes = ["log", "warn", "error", "info"];
  if (!validTypes.includes(type)) return "‚ùå Use one of: log, warn, error, info";

  const logs = window._consoleLogHistory?.filter(log => log.type === type) || [];

  if (logs.length === 0) return `üì≠ No '${type}' logs found.`;

  logs.forEach(({ message }) => {
    const line = document.createElement("div");
    line.textContent = message;
    line.style.fontFamily = "monospace";
    line.style.color = type === "error" ? "#f55" :
                       type === "warn" ? "#ff0" :
                       type === "info" ? "#0af" : "#0f0";
    terminal.appendChild(line);
  });

  terminal.scrollTop = terminal.scrollHeight;
  return `üîé Showing ${logs.length} '${type}' logs.`;
});

registerCommand("log", (args) => {
  const msg = args.join(" ");
  if (!msg) return "‚ùå No message provided.";
  console.log("[manual]", msg);
  return `üìù Logged: ${msg}`;
});




window._consoleLogHistory = [];

(function hookConsoleLive() {
  const types = ["log", "warn", "error", "info"];
  for (const type of types) {
    const original = console[type];
    console[type] = (...args) => {
      const message = `[${type}] ${args.join(" ")}`;
      window._consoleLogHistory.push({ type, message });

      // If debug window is open, update it live
      if (window._debugOutput) {
        const line = document.createElement("div");
        line.textContent = message;
        line.style.fontFamily = "monospace";
        line.style.color =
          type === "error" ? "#f55" :
          type === "warn"  ? "#ff0" :
          type === "info"  ? "#0af" :
          "#0f0";
        window._debugOutput.appendChild(line);
        window._debugOutput.scrollTop = window._debugOutput.scrollHeight;
      }

      original.apply(console, args);
    };
  }
})();

registerCommand("debug", () => {
  if (document.getElementById("debug-window")) {
    return "‚ö†Ô∏è Debug window already open.";
  }

  const win = document.createElement("div");
  win.id = "debug-window";
  win.style.position = "fixed";
  win.style.bottom = "20px";
  win.style.right = "20px";
  win.style.width = "400px";
  win.style.height = "300px";
  win.style.background = "#111";
  win.style.border = "2px solid #0f0";
  win.style.borderRadius = "8px";
  win.style.overflow = "hidden";
  win.style.zIndex = 9999;
  win.style.display = "flex";
  win.style.flexDirection = "column";

  const title = document.createElement("div");
  title.textContent = "üß™ Debug Console";
  title.style.background = "#0f0";
  title.style.color = "#000";
  title.style.padding = "5px 10px";
  title.style.fontFamily = "monospace";
  title.style.cursor = "move";

  const output = document.createElement("div");
  output.style.flex = "1";
  output.style.padding = "10px";
  output.style.overflowY = "auto";
  output.style.fontFamily = "monospace";
  output.style.fontSize = "12px";
  output.style.color = "#0f0";
  output.style.background = "#111";

  win.appendChild(title);
  win.appendChild(output);
  document.body.appendChild(win);

  window._debugOutput = output;

  // Fill with previous logs
  window._consoleLogHistory.forEach(({ type, message }) => {
    const line = document.createElement("div");
    line.textContent = message;
    line.style.color =
      type === "error" ? "#f55" :
      type === "warn"  ? "#ff0" :
      type === "info"  ? "#0af" :
      "#0f0";
    output.appendChild(line);
  });

  output.scrollTop = output.scrollHeight;

  // Make window draggable
  let isDragging = false;
  let offsetX, offsetY;

  title.addEventListener("mousedown", (e) => {
    isDragging = true;
    offsetX = e.clientX - win.getBoundingClientRect().left;
    offsetY = e.clientY - win.getBoundingClientRect().top;
    document.body.style.userSelect = "none";
  });

  document.addEventListener("mouseup", () => {
    isDragging = false;
    document.body.style.userSelect = "auto";
  });

  document.addEventListener("mousemove", (e) => {
    if (isDragging) {
      win.style.left = `${e.clientX - offsetX}px`;
      win.style.top = `${e.clientY - offsetY}px`;
      win.style.right = "auto";
      win.style.bottom = "auto";
    }
  });

  return "üß™ Debug window opened.";
});

console.log("Hello world!");
console.warn("Never buy doors in an online game of zombies!!");
console.error("Uh oh!");


registerCommand("closedebug", () => {
  const win = document.getElementById("debug-window");
  if (win) {
    win.remove();
    window._debugOutput = null;
    return "‚ùå Debug window closed.";
  }
  return "üö´ No debug window is open.";
});

registerCommand("loginchime", () => {
  if (!window.audioCtx) {
    window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  if (window.audioCtx.state === "suspended") {
    window.audioCtx.resume();
  }

  const notes = {
    C5: 523.25,
    E5: 659.25,
    G5: 783.99,
    A5: 880.00
  };

  const chimeSequence = [
    ["C5", 200], ["E5", 200], ["G5", 200], [null, 100],
    ["E5", 200], ["A5", 400]
  ];

  let time = window.audioCtx.currentTime;

  chimeSequence.forEach(([note, duration]) => {
    if (note) {
      const osc = window.audioCtx.createOscillator();
      const gain = window.audioCtx.createGain();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(notes[note], time);
      gain.gain.setValueAtTime(0.15, time);
      osc.connect(gain);
      gain.connect(window.audioCtx.destination);
      osc.start(time);
      osc.stop(time + duration / 1000);
    }
    time += duration / 1000;
  });

  return "";
});

registerCommand("webkernel", () => {
  handleCommand("windowterminal");
  return "üñ•Ô∏è Launching WebKernel...";
});


registerCommand("refresh", () => {
  location.reload();
  return "üîÑ Refreshing...";

})
handleCommand("desktop")
;



let sessionPrintVar = 0;

registerCommand("printvar", () => {
  const output = sessionPrintVar;
  sessionPrintVar++;
  return output.toString(); // ensures compatibility with if-command logic
});


registerCommand("resetvar", () => {
  sessionPrintVar = 0;
  return "‚ôªÔ∏è printvar reset to 0.";
});registerCommand("intnix", () => {
  const container = document.createElement("div");
  container.style.display = "flex";
  container.style.flexDirection = "column";
  container.style.alignItems = "center";
  container.style.justifyContent = "center";
  container.style.margin = "20px 0";

  const canvas = document.createElement("canvas");
  canvas.width = 300;
  canvas.height = 300;
  canvas.style.display = "block";

  container.appendChild(canvas);
  terminal.appendChild(container);

  const ctx = canvas.getContext("2d");
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  let angle = 0;
  let animating = true;

  const drawRotatingTriangle = () => {
    if (!animating) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(angle);
    ctx.translate(-centerX, -centerY);

    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, "#00bfff");
    gradient.addColorStop(0.5, "#00ffaa");
    gradient.addColorStop(1, "#0077ff");

    const drawTriangle = (x, y, width, height, radius) => {
      const points = [
        { x: x, y: y - height / 2 },
        { x: x - width / 2, y: y + height / 2 },
        { x: x + width / 2, y: y + height / 2 }
      ];

      ctx.beginPath();
      for (let i = 0; i < 3; i++) {
        const curr = points[i];
        const next = points[(i + 1) % 3];
        const dx = next.x - curr.x;
        const dy = next.y - curr.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const unitX = dx / dist;
        const unitY = dy / dist;

        const p1x = curr.x + unitX * radius;
        const p1y = curr.y + unitY * radius;
        const p2x = next.x - unitX * radius;
        const p2y = next.y - unitY * radius;

        if (i === 0) ctx.moveTo(p1x, p1y);
        else ctx.lineTo(p1x, p1y);

        ctx.quadraticCurveTo(next.x, next.y, p2x, p2y);
      }

      ctx.closePath();
      ctx.lineWidth = 14;
      ctx.strokeStyle = gradient;
      ctx.stroke();
    };

    drawTriangle(centerX, centerY - 10, 160, 140, 30);

    ctx.restore();

    // Draw text below
    ctx.font = "bold 22px monospace";
    ctx.fillStyle = "#00bfff";
    ctx.textAlign = "center";
    ctx.fillText("INTNIX", centerX, canvas.height - 20);

    angle += 0.02;
    requestAnimationFrame(drawRotatingTriangle);
  };

  drawRotatingTriangle();

  // Stop animation + remove from terminal
  setTimeout(() => {
    animating = false;
    container.remove();
  }, 3600);

  terminal.scrollTop = terminal.scrollHeight;
  return "";
});


registerCommand("blank", () => {
  return ""; // Does nothing, shows nothing
});registerCommand("bottomdock", args => {
  const action = args[0];
  const existingDock = document.getElementById("bottom-dock");

  if (action === "hide") {
    if (existingDock) {
      existingDock.remove();
      return "üì§ Bottom dock hidden.";
    }
    return "‚ùå Bottom dock was not visible.";
  }

  if (action === "show") {
    if (existingDock) return "üì• Bottom dock already visible.";

    // ‚õî Remove any sidedock (match sidedock behavior)
    document.getElementById("side-dock")?.remove();

    const size = parseInt(localStorage.getItem("dockIconSize") || "62");

    // Inject CSS once
    if (!document.getElementById("bottom-dock-style")) {
      const style = document.createElement("style");
      style.id = "bottom-dock-style";
      style.textContent = `
        #bottom-dock {
          position: fixed;
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.6);
          padding: 8px 10px;
          border-radius: 14px;
          display: flex;
          flex-direction: row;
          gap: 10px;
          z-index: 9999;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          max-width: 90vw;
          overflow-x: auto;
          white-space: nowrap;
          align-items: center;
        }

        .dock-icon {
          border-radius: 10px;
          cursor: pointer;
          transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .dock-icon:hover {
          transform: scale(1.2);
          box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        }

        .dock-icon-wrapper {
          position: relative;
        }
      `;
      document.head.appendChild(style);
    }

    const dock = document.createElement("div");
    dock.id = "bottom-dock";

    // Helper: create an icon
    const createIcon = (src, title, command) => {
      const wrapper = document.createElement("div");
      wrapper.className = "dock-icon-wrapper";

      const img = document.createElement("img");
      img.src = src;
      img.title = title;
      img.className = "dock-icon";
      img.style.width = img.style.height = `${size}px`;
      img.onclick = (e) => {
        e?.preventDefault?.();
        e?.stopPropagation?.();
        handleCommand(command);
      };

      wrapper.appendChild(img);
      return wrapper;
    };

    // System icons
    dock.appendChild(createIcon("File.jpg", "Finder", "finder"));
    dock.appendChild(createIcon("terminal.jpg", "Terminal", "windowterminal"));

    // User-added apps
    const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
    const dockItems = fakeFileSystem["/dock"] || [];

    dockItems.forEach(name => {
      const metaKey = Object.keys(appMeta).find(key => key.endsWith(`/${name}`));
      const meta = appMeta[metaKey] || {};
      const isApp = meta.type === "app" || name.endsWith(".oos");
      const icon = meta.icon || (isApp ? "link-icon.png" : "default.jpg");

      const wrapper = document.createElement("div");
      wrapper.className = "dock-icon-wrapper";
      wrapper.id = `bottomdock-wrapper-${name}`;

      const img = document.createElement("img");
      img.src = icon;
      img.title = name;
      img.className = "dock-icon";
      img.style.width = img.style.height = `${size}px`;
      img.onclick = (e) => {
        e?.preventDefault?.();
        e?.stopPropagation?.();
        handleCommand(`launch ${name}`);
      };

      wrapper.appendChild(img);
      dock.appendChild(wrapper);
    });

    document.body.appendChild(dock);
    return "üì• Bottom dock shown.";
  }

  return "‚ùå Usage: bottomdock [show|hide]";
});

registerCommand("dockicon", args => {
  const sizeRaw = args[0];
  if (!sizeRaw || isNaN(parseInt(sizeRaw))) {
    return "‚ùå Usage: dockicon [size in px]";
  }

  const size = parseInt(sizeRaw);
  const cssId = "dock-icon-size-style";
  const existing = document.getElementById(cssId);

  if (existing) existing.remove();

  const style = document.createElement("style");
  style.id = cssId;
  style.textContent = `
    .dock-icon {
      width: ${size}px !important;
      height: ${size}px !important;
    }
  `;
  document.head.appendChild(style);

  // üì° Send to all iframes (in case dock is inside one)
  const iframes = document.querySelectorAll("iframe");
  iframes.forEach(iframe => {
    iframe.contentWindow.postMessage({
      type: "update-dock-icon-size",
      size
    }, "*");
  });

  return `üéØ Dock icon size set to ${size}px in all views.`;
});

registerCommand("sidedock", args => {
  const side = args[0];
  const existingDock = document.getElementById("side-dock");

  if (!["left", "right"].includes(side)) {
    return "‚ùå Usage: sidedock [left|right]";
  }

  if (existingDock) existingDock.remove();

  const dock = document.createElement("div");
  dock.id = "side-dock";
  Object.assign(dock.style, {
    position: "fixed",
    top: "50%",
    transform: "translateY(-50%)",
    background: "rgba(0, 0, 0, 0.8)",
    padding: "12px 8px",
    borderRadius: "12px",
    display: "flex",
    flexDirection: "column",
    gap: "8px",
    zIndex: "9999",
    boxShadow: "0 5px 15px rgba(0,0,0,0.5)",
    [side]: "10px"
  });

  // Inject dock icon styles if needed
  if (!document.getElementById("sidedock-style")) {
    const style = document.createElement("style");
    style.id = "sidedock-style";
    style.textContent = `
      .dock-icon {
        width: 42px;
        height: 42px;
        border-radius: 10px;
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      .dock-icon:hover {
        transform: scale(1.2);
      }
      .dock-icon-wrapper {
        position: relative;
      }
    `;
    document.head.appendChild(style);
  }

  // === Finder Icon ===
  const finderWrapper = document.createElement("div");
  finderWrapper.className = "dock-icon-wrapper";

  const finderIcon = document.createElement("img");
  finderIcon.src = "File.jpg";
  finderIcon.title = "Finder";
  finderIcon.className = "dock-icon";
  finderIcon.onclick = () => handleCommand("finder");

  finderWrapper.appendChild(finderIcon);
  dock.appendChild(finderWrapper);

  // === Terminal Icon ===
  const terminalWrapper = document.createElement("div");
  terminalWrapper.className = "dock-icon-wrapper";

  const terminalIcon = document.createElement("img");
  terminalIcon.src = "terminal.jpg";
  terminalIcon.title = "Terminal";
  terminalIcon.className = "dock-icon";
  terminalIcon.onclick = () => handleCommand("windowterminal");

  terminalWrapper.appendChild(terminalIcon);
  dock.appendChild(terminalWrapper);

  // === User-added apps from /dock ===
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  const dockItems = fakeFileSystem["/dock"] || [];

  dockItems.forEach(name => {
    const metaKey = Object.keys(appMeta).find(key => key.endsWith(`/${name}`));
    const meta = appMeta[metaKey] || {};
    const isApp = meta.type === "app" || name.endsWith(".oos");
    const icon = meta.icon || (isApp ? 'link-icon.png' : 'default.jpg');

    const wrapper = document.createElement("div");
    wrapper.className = "dock-icon-wrapper";
    wrapper.id = `sidedock-wrapper-${name}`;

    const img = document.createElement("img");
    img.src = icon;
    img.title = name;
    img.className = "dock-icon";
    img.onclick = () => handleCommand(`launch ${name}`);

    wrapper.appendChild(img);
    dock.appendChild(wrapper);
  });

  document.body.appendChild(dock);
  return `üìå Side dock added to the ${side}.`;
});
registerCommand("savedockstate", () => {
  const dockState = {};

  if (document.getElementById("bottom-dock")) {
    dockState.type = "bottomdock";
  } else if (document.getElementById("side-dock")) {
    dockState.type = "sidedock";
    dockState.side = document.getElementById("side-dock").style.left === "10px" ? "left" : "right";
  } else if (document.getElementById("bubble-dock")) {
    dockState.type = "bubbledock";
  } else if (document.getElementById("intnix-dock")) {
    dockState.type = "intnixdock";
  } else if (document.getElementById("retrodock")) {
    dockState.type = "retrodock";
  } else if (document.getElementById("bubble-dock")) {
    dockState.type = "bubbledock";
  } else {
    return "‚ùå No active dock found to save.";
  }

  localStorage.setItem("dockState", JSON.stringify(dockState));
  return `üíæ Dock state saved: ${dockState.type}${dockState.side ? " (" + dockState.side + ")" : ""}.`;
});



registerCommand("dock", args => {
    executeCommand("dockrefresh");
  const position = args[0];
  const validPositions = ["left", "right", "bottom", "hide"];
  if (!validPositions.includes(position)) {
    return "‚ùå Usage: dock [left|right|bottom|hide]";
  }

  // Remove any existing dock
  document.getElementById("bottom-dock")?.remove();
  document.getElementById("side-dock")?.remove();

  if (position === "hide") {
    return "üì§ Dock hidden.";
  }

  const size = parseInt(localStorage.getItem("dockIconSize") || "62");

  // Inject dock CSS once
  if (!document.getElementById("dock-style")) {
    const style = document.createElement("style");
    style.id = "dock-style";
    style.textContent = `
      .dock-icon {
        border-radius: 10px;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .dock-icon:hover {
        transform: scale(1.2);
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
      }
      .dock-icon-wrapper {
        position: relative;
      }
    `;
    document.head.appendChild(style);
  }

  // Create dock container
  const dock = document.createElement("div");
  const isSide = position === "left" || position === "right";
  dock.id = isSide ? "side-dock" : "bottom-dock";

  // Apply styles
  Object.assign(dock.style, {
    position: "fixed",
    background: "rgba(0, 0, 0, 0.6)",
    padding: "8px 10px",
    borderRadius: "14px",
    display: "flex",
    gap: "10px",
    zIndex: "9999",
    boxShadow: "0 5px 15px rgba(0,0,0,0.5)",
    overflow: "auto",
    alignItems: "center"
  });

  if (isSide) {
    dock.style.flexDirection = "column";
    dock.style.top = "50%";
    dock.style.transform = "translateY(-50%)";
    dock.style[position] = "10px";
  } else {
    dock.style.flexDirection = "row";
    dock.style.bottom = "20px";
    dock.style.left = "50%";
    dock.style.transform = "translateX(-50%)";
    dock.style.maxWidth = "90vw";
    dock.style.whiteSpace = "nowrap";
  }

  // Helper for icons
  const createIcon = (src, title, command) => {
    const wrapper = document.createElement("div");
    wrapper.className = "dock-icon-wrapper";

    const img = document.createElement("img");
    img.src = src;
    img.title = title;
    img.className = "dock-icon";
    img.style.width = img.style.height = `${size}px`;
    img.onclick = (e) => {
      e?.preventDefault?.();
      e?.stopPropagation?.();
      handleCommand(command);
    };

    wrapper.appendChild(img);
    return wrapper;
  };

  // System apps
  dock.appendChild(createIcon("File.jpg", "Finder", "finder"));
  dock.appendChild(createIcon("terminal.jpg", "Terminal", "windowterminal"));

  // User apps
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  const dockItems = fakeFileSystem["/dock"] || [];

  dockItems.forEach(name => {
    const metaKey = Object.keys(appMeta).find(k => k.endsWith(`/${name}`));
    const meta = appMeta[metaKey] || {};
    const isApp = meta.type === "app" || name.endsWith(".oos");
    const icon = meta.icon || (isApp ? "link-icon.png" : "default.jpg");

    const wrapper = document.createElement("div");
    wrapper.className = "dock-icon-wrapper";
    wrapper.id = `dock-wrapper-${name}`;

    const img = document.createElement("img");
    img.src = icon;
    img.title = name;
    img.className = "dock-icon";
    img.style.width = img.style.height = `${size}px`;
    img.onclick = (e) => {
      e?.preventDefault?.();
      e?.stopPropagation?.();
      handleCommand(`launch ${name}`);
    };

    wrapper.appendChild(img);
    dock.appendChild(wrapper);
  });

  document.body.appendChild(dock);
  return `üìå Dock added to the ${position}.`;
});
registerCommand("bubbledock", () => {
  executeCommand("dockrefresh");

  if (document.getElementById("bubble-dock")) {
    return "‚ùó Bubble dock already visible.";
  }

  const size = parseInt(localStorage.getItem("dockIconSize") || "60");

  // Inject bubble style
  if (!document.getElementById("bubble-dock-style")) {
    const style = document.createElement("style");
    style.id = "bubble-dock-style";
    style.textContent = `
      #bubble-dock {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: transparent;
        padding: 6px 10px;
        display: flex;
        flex-direction: row;
        align-items: flex-end;
        justify-content: center;
        gap: 18px;
        z-index: 9999;
        pointer-events: auto;
      }

      .bubble-icon {
        width: ${size}px;
        height: ${size}px;
        border-radius: 50%;
        cursor: pointer;
        object-fit: cover;
        background: radial-gradient(circle at 30% 30%, #ffffff44, #ffffff00);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        transition: transform 0.25s ease, filter 0.2s ease, box-shadow 0.2s ease;
      }

      .bubble-icon:hover {
        transform: translateY(-8px) scale(1.1);
        filter: brightness(1.15);
        box-shadow: 0 8px 14px rgba(255, 255, 255, 0.25);
      }
    `;
    document.head.appendChild(style);
  }

  const dock = document.createElement("div");
  dock.id = "bubble-dock";

  const createIcon = (src, title, command) => {
    const img = document.createElement("img");
    img.src = src;
    img.title = title;
    img.className = "bubble-icon";
    img.onclick = (e) => {
      e?.preventDefault?.();
      e?.stopPropagation?.();
      handleCommand(command);
    };
    return img;
  };

  // Core apps
  dock.appendChild(createIcon("File.jpg", "Finder", "finder"));
  dock.appendChild(createIcon("terminal.jpg", "Terminal", "windowterminal"));

  // User apps
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  const dockItems = fakeFileSystem["/dock"] || [];

  dockItems.forEach(name => {
    const metaKey = Object.keys(appMeta).find(k => k.endsWith(`/${name}`));
    const meta = appMeta[metaKey] || {};
    const icon = meta.icon || (name.endsWith(".oos") ? "link-icon.png" : "default.jpg");

    const img = document.createElement("img");
    img.src = icon;
    img.title = name;
    img.className = "bubble-icon";
    img.onclick = (e) => {
      e?.preventDefault?.();
      e?.stopPropagation?.();
      handleCommand(`launch ${name}`);
    };

    dock.appendChild(img);
  });

  document.body.appendChild(dock);
  return "ü´ß Bubble dock shown!";
});

registerCommand("intnixdock", () => {
  executeCommand("dockrefresh");

  if (document.getElementById("windows-dock")) return "‚ùó Windows dock already visible.";

  const size = parseInt(localStorage.getItem("dockIconSize") || "54");

  // Inject styles
  if (!document.getElementById("windows-dock-style")) {
    const style = document.createElement("style");
    style.id = "windows-dock-style";
    style.textContent = `
      #windows-dock {
        position: fixed;
        bottom: 12px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(40, 40, 40, 0.75);
        backdrop-filter: blur(10px);
        padding: 6px 12px;
        display: flex;
        align-items: center;
        gap: 14px;
        z-index: 9999;
        border-radius: 18px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      }

      .win-dock-icon {
        width: ${size}px;
        height: ${size}px;
        border-radius: 12px;
        cursor: pointer;
        object-fit: cover;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .win-dock-icon:hover {
        transform: scale(1.1);
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
      }

      .win-dock-divider {
        width: 1px;
        height: ${size}px;
        background: rgba(255,255,255,0.1);
        margin: 0 6px;
      }
    `;
    document.head.appendChild(style);
  }

  const dock = document.createElement("div");
  dock.id = "windows-dock";

  const createIcon = (src, title, command) => {
    const img = document.createElement("img");
    img.src = src;
    img.title = title;
    img.className = "win-dock-icon";
    img.onclick = (e) => {
      e?.preventDefault?.();
      e?.stopPropagation?.();
      handleCommand(command);
    };
    return img;
  };

  // === System Icons ===

  dock.appendChild(createIcon("File.jpg", "Explorer", "finder"));
  dock.appendChild(createIcon("terminal.jpg", "Terminal", "windowterminal"));

  // Divider
  const divider = document.createElement("div");
  divider.className = "win-dock-divider";
  dock.appendChild(divider);

  // === User Apps ===
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  const dockItems = fakeFileSystem["/dock"] || [];

  dockItems.forEach(name => {
    const metaKey = Object.keys(appMeta).find(k => k.endsWith(`/${name}`));
    const meta = appMeta[metaKey] || {};
    const icon = meta.icon || (name.endsWith(".oos") ? "link-icon.png" : "default.jpg");

    const img = document.createElement("img");
    img.src = icon;
    img.title = name;
    img.className = "win-dock-icon";
    img.onclick = (e) => {
      e?.preventDefault?.();
      e?.stopPropagation?.();
      handleCommand(`launch ${name}`);
    };

    dock.appendChild(img);
  });

  document.body.appendChild(dock);
  return "ü™ü Windows-style taskbar shown.";
});

registerCommand("dockrefresh", () => {
  const dockIds = [
    "bottom-dock",
    "side-dock",
    "bubble-dock",
    "retrodock",
    "intnix-dock",
    "bubble-dock",
    "custom-dock"
  ];

  let removed = 0;

  dockIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.remove();
      removed++;
    }
  });

  return removed ? `üßπ Removed ${removed} dock(s).` : "‚úÖ No docks were visible.";
});


registerCommand("retrodock", () => {
  // Remove other docks
  executeCommand("dockrefresh");

  if (document.getElementById("retrodock")) {
    return "‚ùó Retro dock already visible.";
  }

  const size = parseInt(localStorage.getItem("dockIconSize") || "48");

  // Style
  if (!document.getElementById("retrodock-style")) {
    const style = document.createElement("style");
    style.id = "retrodock-style";
    style.textContent = `
      #retrodock {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background: #C0C0C0;
        padding: 4px 6px;
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 8px;
        z-index: 9999;
        border-top: 2px solid #FFFFFF;
        border-left: 2px solid #FFFFFF;
        border-right: 2px solid #404040;
        border-bottom: 2px solid #404040;
        box-shadow: inset -1px -1px 0 #808080, inset 1px 1px 0 #FFF;
      }

      .retro-icon {
        width: ${size}px;
        height: ${size}px;
        image-rendering: pixelated;
        border: 2px outset #d0d0d0;
        background: #dcdcdc;
        padding: 2px;
        cursor: pointer;
        transition: none;
      }

      .retro-icon:hover {
        border: 2px inset #d0d0d0;
        background: #e0e0e0;
      }
    `;
    document.head.appendChild(style);
  }

  const dock = document.createElement("div");
  dock.id = "retrodock";

  const createIcon = (src, title, command) => {
    const img = document.createElement("img");
    img.src = src;
    img.title = title;
    img.className = "retro-icon";
    img.onclick = (e) => {
      e?.preventDefault?.();
      e?.stopPropagation?.();
      handleCommand(command);
    };
    return img;
  };

  // System icons
  dock.appendChild(createIcon("File.jpg", "Finder", "finder"));
  dock.appendChild(createIcon("terminal.jpg", "Terminal", "windowterminal"));

  // User apps
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  const dockItems = fakeFileSystem["/dock"] || [];

  dockItems.forEach(name => {
    const metaKey = Object.keys(appMeta).find(k => k.endsWith(`/${name}`));
    const meta = appMeta[metaKey] || {};
    const icon = meta.icon || (name.endsWith(".oos") ? "link-icon.png" : "default.jpg");

    const img = document.createElement("img");
    img.src = icon;
    img.title = name;
    img.className = "retro-icon";
    img.onclick = (e) => {
      e?.preventDefault?.();
      e?.stopPropagation?.();
      handleCommand(`launch ${name}`);
    };

    dock.appendChild(img);
  });

  document.body.appendChild(dock);
  return "üñ•Ô∏è Retro dock shown (Windows 98 style).";
});

registerCommand("dockmenu", () => {
  if (document.getElementById("dock-menu")) {
    document.getElementById("dock-menu").remove();
    return "‚ùå Closed dock menu.";
  }

  // Inject style
  if (!document.getElementById("dock-menu-style")) {
    const style = document.createElement("style");
    style.id = "dock-menu-style";
    style.textContent = `
      #dock-menu {
        position: fixed;
        top: 18%;
        left: 10%;
        transform: translate(-50%, -50%);
        background: rgba(25, 25, 25, 0.95);
        backdrop-filter: blur(8px);
        border-radius: 12px;
        padding: 12px;
        z-index: 99999;
        box-shadow: 0 8px 24px rgba(0,0,0,0.5);
        min-width: 240px;
        display: flex;
        flex-direction: column;
        font-family: sans-serif;
      }

      .dock-menu-item {
        padding: 10px 14px;
        color: white;
        font-size: 14px;
        cursor: pointer;
        border-radius: 6px;
        transition: background 0.2s;
      }

      .dock-menu-item:hover {
        background: rgba(255, 255, 255, 0.1);
      }
    `;
    document.head.appendChild(style);
  }

  const dockMenu = document.createElement("div");
  dockMenu.id = "dock-menu";

  const options = [
    { label: "ü´ß Bubble Dock", command: "bubbledock" },
    { label: "üåÄ Intnix Dock", command: "intnixdock" },
      { label: "üñ•Ô∏è Retro Dock", command: "retrodock" },
    { label: "‚¨ÖÔ∏è Dock Left", command: "sidedock left" },
    { label: "‚û°Ô∏è Dock Right", command: "sidedock right" },
    { label: "‚¨áÔ∏è Dock Bottom", command: "bottomdock show" },
    { label: "‚ùå Hide Dock", command: "dockrefresh" }
  ];

  options.forEach(opt => {
    const item = document.createElement("div");
    item.className = "dock-menu-item";
    item.textContent = opt.label;
    item.onclick = () => {
      handleCommand(opt.command);
      if (opt.command !== "dockrefresh") {
        setTimeout(() => handleCommand("savedockstate"), 300);
      }
      dockMenu.remove();
    };
    dockMenu.appendChild(item);
  });

  document.body.appendChild(dockMenu);
  return "üì¶ Dock menu opened.";
});

registerCommand("applauncher", () => {
  if (document.getElementById("app-launcher")) {
    document.getElementById("app-launcher").remove();
    return "‚ùå Closed app launcher.";
  }

  // Style block (only inject once)
  if (!document.getElementById("app-launcher-style")) {
    const style = document.createElement("style");
    style.id = "app-launcher-style";
    style.textContent = `
      @keyframes launcherFade {
        from { opacity: 0; transform: scale(0.95); }
        to { opacity: 1; transform: scale(1); }
      }

      #app-launcher {
        position: fixed;
        top: 0; left: 0;
        width: 100%;
        height: 100%;
        background: rgba(10, 10, 10, 0.94);
        backdrop-filter: blur(10px);
        z-index: 99999;
        display: flex;
        flex-direction: column;
        padding: 40px 60px 80px;
        overflow-y: auto;
        animation: launcherFade 0.3s ease-out;
      }

      #launcher-search {
        width: 100%;
        max-width: 520px;
        margin: 0 auto 30px;
        padding: 12px 18px;
        font-size: 16px;
        border-radius: 12px;
        border: none;
        outline: none;
        background: #1a1a1a;
        color: #eee;
        font-family: sans-serif;
        box-shadow: inset 0 0 0 1px #444;
      }

      #launcher-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 36px;
      justify-items: center;
      max-width: 1100px;
      margin: 0 auto;
      width: 100%;
    }



      .launcher-app {
        width: 120px;
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        color: white;
        font-family: 'Segoe UI', sans-serif;
        transition: transform 0.2s ease;
      }

      .launcher-app:hover {
        transform: scale(1.5);
      }

      .launcher-app img {
        width: 100px;
        height: 100px;
        border-radius: 16px;
        object-fit: cover;
        margin-bottom: 8px;
        background: #1a1a1a;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      }

      .launcher-app span {
        font-size: 13px;
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 110px;
        color: #eee;
      }

      .launcher-path {
        font-size: 10px;
        color: #888;
        text-align: center;
        margin-top: -4px;
        max-width: 110px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
    `;
    document.head.appendChild(style);
  }

  // Launcher container
  const launcher = document.createElement("div");
  launcher.id = "app-launcher";

  const searchInput = document.createElement("input");
  searchInput.id = "launcher-search";
  searchInput.placeholder = "Search files or apps system-wide...";

  const grid = document.createElement("div");
  grid.id = "launcher-grid";

  launcher.appendChild(searchInput);
  launcher.appendChild(grid);
  document.body.appendChild(launcher);

  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");

  const renderItems = (paths) => {
    grid.innerHTML = "";
    paths.forEach(fullPath => {
      const name = fullPath.split("/").pop();
      const metaKey = Object.keys(appMeta).find(k => k.endsWith(`/${name}`));
      const meta = appMeta[metaKey] || {};
      const icon = meta.icon || (name.endsWith(".oos") ? "link-icon.png" : "default.jpg");

      const wrapper = document.createElement("div");
      wrapper.className = "launcher-app";

      const img = document.createElement("img");
      img.src = icon;
      img.alt = name;

      const label = document.createElement("span");
      label.textContent = name;

      const pathText = document.createElement("div");
      pathText.className = "launcher-path";
      pathText.textContent = fullPath;

      wrapper.appendChild(img);
      wrapper.appendChild(label);
      wrapper.appendChild(pathText);

      wrapper.onclick = () => {
        handleCommand(`launch ${fullPath}`);
        launcher.remove();
      };

      grid.appendChild(wrapper);
    });
  };

  // Initial load ‚Äî just /apps
  const appsFolder = fakeFileSystem["/apps"] || [];
  renderItems(appsFolder.map(name => `/apps/${name}`));

  // Global live search using `find`
  searchInput.addEventListener("input", () => {
    const term = searchInput.value.trim();
    if (!term) {
      renderItems(appsFolder.map(name => `/apps/${name}`));
      return;
    }

    const raw = handleCommand(`find ${term}`);
    const paths = typeof raw === "string"
      ? raw.split("\n").filter(line => line.trim().startsWith("/"))
      : [];

    renderItems(paths);
  });

  // Escape to close
  const close = () => launcher.remove();
  setTimeout(() => {
    launcher.addEventListener("click", (e) => {
      if (e.target === launcher) close();
    });
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") close();
    }, { once: true });
  }, 100);

  return "üîç App launcher opened with global search!";
});

window.addEventListener("keydown", (e) => {
  const isTyping = e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.isContentEditable;

  if (!isTyping && e.key.toLowerCase() === "l") {
    e.preventDefault();
    handleCommand("applauncher");
  }
});
registerCommand("aerodock", () => {
  if (document.getElementById("aerodock")) {
    return "ü™ü AeroDock is already visible.";
  }

  if (!document.getElementById("aerodock-style")) {
    const style = document.createElement("style");
    style.id = "aerodock-style";
    style.textContent = `
    #aerodock {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 98vw;
      max-width: 1400px;
      height: 44px;
      background: rgba(10, 10, 10, 0.85); /* ‚úÖ darker RGB but still translucent */
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.04);
      border-radius: 14px 14px 0 0;
      box-shadow: 0 -4px 30px rgba(0, 0, 0, 0.6);
      z-index: 9999;
      display: flex;
      align-items: center;
      gap: 16px;
      font-family: monospace;
      color: #fff;
      padding: 0 18px;
    }


#aerodock .win-btn {
  width: 40px;
  height: 40px;
  background: rgba(255, 255, 255, 0.08);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.1);
  color: white;
  font-size: 18px;
  font-weight: bold;
  backdrop-filter: blur(10px);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
}

#aerodock .win-btn:hover {
  background: rgba(255,255,255,0.15);
  transform: scale(1.05);
}

#aerodock .dock-search {
  flex-grow: 1;
  background: rgba(255, 255, 255, 0.05);
  color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.15);
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 14px;
  outline: none;
  backdrop-filter: blur(12px);
}

.aero-dock-icon {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  background: rgba(255, 255, 255, 0.1);
  object-fit: cover;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}

.aero-dock-icon:hover {
  transform: scale(1.15);
  box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
}

.dock-wrapper {
  position: relative;
}

.dock-indicator {
  position: absolute;
  bottom: -6px;
  left: 50%;
  transform: translateX(-50%);
  width: 6px;
  height: 6px;
  background: white;
  border-radius: 50%;
  display: none;
}

.dock-wrapper.active .dock-indicator {
  display: block;
}

#dock-suggestions {
  position: absolute;
  bottom: 100%;
  left: 0;
  right: 0;
  background: rgba(30, 30, 30, 0.85); /* darker background for contrast */
  border: 1px solid rgba(255, 255, 255, 0.15);
  color: #fff;
  z-index: 1000;
  max-height: 180px;
  overflow-y: auto;
  display: none;
  font-size: 14px;
  border-radius: 8px 8px 0 0;
  margin-bottom: 8px;
  backdrop-filter: blur(20px);
  box-shadow: 0 -6px 16px rgba(0, 0, 0, 0.6);
}

#dock-suggestions div {
  padding: 8px 12px;
  cursor: pointer;
  transition: background 0.2s ease;
}

#dock-suggestions div:hover,
#dock-suggestions div.active {
  background: rgba(255, 255, 255, 0.1);
}


#dock-suggestions div {
  padding: 6px 10px;
  cursor: pointer;
}

#dock-suggestions div:hover,
#dock-suggestions div.active {
  background: rgba(255,255,255,0.1);
}

    `;
    document.head.appendChild(style);
  }

  const dock = document.createElement("div");
  dock.id = "aerodock";

  const winBtn = document.createElement("button");
  winBtn.className = "win-btn";
  winBtn.textContent = "ü™ü";
  winBtn.onclick = () => handleCommand("applauncher");

  const appBtn = document.createElement("button");
  appBtn.className = "win-btn";
  appBtn.textContent = "‚¨áÔ∏è";
  appBtn.onclick = () => handleCommand("appdownload");

  const settingsBtn = document.createElement("button");
  settingsBtn.className = "win-btn";
  settingsBtn.textContent = "‚öôÔ∏è";
  settingsBtn.onclick = () => handleCommand("cc");

  const finderBtn = document.createElement("button");
finderBtn.className = "win-btn";
finderBtn.textContent = "üóÇÔ∏è";
finderBtn.onclick = () => handleCommand("files");

const terminalBtn = document.createElement("button");
terminalBtn.className = "win-btn";
terminalBtn.textContent = "üíª";
terminalBtn.onclick = () => handleCommand("windowterminal");


const textEditorBtn = document.createElement("button");
textEditorBtn.className = "win-btn";
textEditorBtn.textContent = "üìù";
textEditorBtn.title = "Text Editor";
textEditorBtn.onclick = () => handleCommand("edit");

const nebulaBtn = document.createElement("button");
nebulaBtn.className = "win-btn";
nebulaBtn.textContent = "ü™ê";
nebulaBtn.title = "Nebula";
nebulaBtn.onclick = () => handleCommand("nebula");


  const searchWrapper = document.createElement("div");
  searchWrapper.style.position = "relative";
  searchWrapper.style.flex = "1";
  searchWrapper.style.maxWidth = "240px";

  const search = document.createElement("input");
  search.className = "dock-search";
  search.placeholder = "Enter command...";
  searchWrapper.appendChild(search);

  const suggestionBox = document.createElement("div");
  suggestionBox.id = "dock-suggestions";
  searchWrapper.appendChild(suggestionBox);

  let selectedIndex = -1;
  const getMatchingCommands = (input) => {
    return Object.keys(commands).filter(cmd =>
      cmd.toLowerCase().startsWith(input.toLowerCase())
    );
  };

  search.addEventListener("input", () => {
    const value = search.value.trim();
    suggestionBox.innerHTML = "";
    selectedIndex = -1;

    if (!value) {
      suggestionBox.style.display = "none";
      return;
    }

    const matches = getMatchingCommands(value).slice(0, 6);
    matches.forEach((match, i) => {
      const item = document.createElement("div");
      item.textContent = match;

      item.addEventListener("click", () => {
        search.value = "";
        suggestionBox.style.display = "none";
        handleCommand(match);
      });

      suggestionBox.appendChild(item);
    });

    suggestionBox.style.display = matches.length ? "block" : "none";
  });

  search.addEventListener("keydown", (e) => {
    const items = suggestionBox.querySelectorAll("div");
    if (!items.length) return;

    if (e.key === "ArrowDown") {
      selectedIndex = (selectedIndex + 1) % items.length;
      items.forEach((el, i) => {
        el.classList.toggle("active", i === selectedIndex);
      });
      e.preventDefault();
    }

    if (e.key === "ArrowUp") {
      selectedIndex = (selectedIndex - 1 + items.length) % items.length;
      items.forEach((el, i) => {
        el.classList.toggle("active", i === selectedIndex);
      });
      e.preventDefault();
    }

    if (e.key === "Enter") {
      if (selectedIndex !== -1) {
        const selected = items[selectedIndex];
        const cmd = selected.textContent;
        handleCommand(cmd);
        search.value = "";
        suggestionBox.style.display = "none";
      } else {
        handleCommand(search.value.trim());
        search.value = "";
        suggestionBox.style.display = "none";
      }
    }

    if (e.key === "Escape") {
      search.value = "";
      suggestionBox.style.display = "none";
    }
  });

    dock.appendChild(searchWrapper);
  dock.appendChild(winBtn);
  dock.appendChild(appBtn);
  dock.appendChild(settingsBtn);
      dock.appendChild(terminalBtn);
      dock.appendChild(finderBtn);







  const addDockIcon = (name, icon, command) => {
    if (document.getElementById(`dock-wrapper-${name}`)) return;

    const wrapper = document.createElement("div");
    wrapper.className = "dock-wrapper";
    wrapper.id = `dock-wrapper-${name}`;

    const img = document.createElement("img");
    img.src = icon;
    img.title = name;
    img.className = "aero-dock-icon";
    img.onclick = () => handleCommand(command);

    const dot = document.createElement("div");
    dot.className = "dock-indicator";

    wrapper.appendChild(img);
    wrapper.appendChild(dot);
    dock.appendChild(wrapper);
  };

  // Finder + Terminal



  // User dock apps
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  const dockItems = fakeFileSystem["/dock"] || [];
  dockItems.forEach(name => {
    const metaKey = Object.keys(appMeta).find(k => k.endsWith(`/${name}`));
    const meta = appMeta[metaKey] || {};
    const icon = meta.icon || (name.endsWith(".oos") ? "link-icon.png" : "default.jpg");
    addDockIcon(name, icon, `launch ${name}`);
  });

  document.body.appendChild(dock);

  window.addEventListener("message", (e) => {
    if (e.data.type === "app-open" && e.data.name) {
      const name = e.data.name;
      const icon = e.data.icon || "default.jpg";
      const isFile = name.includes(".") && !name.endsWith(".oos") && !name.endsWith(".app");
      const iconPath = isFile ? "default.jpg" : icon;

      addDockIcon(name, iconPath, `launch ${name}`);

      const wrapper = document.getElementById(`dock-wrapper-${name}`);
      if (wrapper) wrapper.classList.add("active");
    }

    if (e.data.type === "app-closed" && e.data.name) {
      const wrapper = document.getElementById(`dock-wrapper-${e.data.name}`);
      if (wrapper) wrapper.classList.remove("active");
    }
  });

  return "ü™ü AeroDock with smart autocomplete loaded.";
});


registerCommand("hideaerodock", () => {
  const dock = document.getElementById("aerodock");
  if (dock) {
    dock.remove();
    return "üßº AeroDock hidden.";
  } else {
    return "‚ùå AeroDock is not visible.";
  }
});

registerCommand("reload", () => {
  executeCommand("closedesktop");
  executeCommand("desktop");
  executeCommand("advertisement");

  return "üîÑ Reloading desktop...";
});
registerCommand("appdownload", async () => {
  if (document.getElementById("app-download-ui")) {
    document.getElementById("app-download-ui").remove();
    return "‚ùå Closed app download window.";
  }

  let apps = [];
  try {
    const res = await fetch("pkgMan.json");
    const data = await res.json();
    apps = Object.entries(data);
  } catch (e) {
    return "‚ùå Failed to load pkgMan.json.";
  }

  if (apps.length === 0) return "üì≠ No apps available in pkgMan.json.";

  // Load installed apps from /apps
  const currentUser = localStorage.getItem("currentUser") || "admin";
  const fileSystem = JSON.parse(localStorage.getItem("userFileSystems") || "{}")[currentUser] || {};
  const installedApps = fileSystem["/apps"] || [];

  // Inject styles
  if (!document.getElementById("app-download-style")) {
    const style = document.createElement("style");
    style.id = "app-download-style";
    style.textContent = `
#app-download-ui {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(255, 255, 255, 0.06);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  z-index: 99999;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 48px;
  overflow-y: auto;
  font-family: 'Segoe UI', sans-serif;
}

#app-download-ui h1 {
  font-size: 28px;
  color: white;
  text-align: center;
  margin-bottom: 24px;
  font-weight: 600;
}

.app-card {
  display: flex;
  align-items: center;
  gap: 20px;
  padding: 18px 20px;
  margin: 0 auto 20px;
  max-width: 700px;
  width: 100%;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.15);
  border-radius: 14px;
  box-shadow: 0 6px 20px rgba(0,0,0,0.2);
  transition: background 0.3s ease;
}

.app-card:hover {
  background: rgba(255, 255, 255, 0.12);
}

.app-card img {
  width: 60px;
  height: 60px;
  border-radius: 12px;
  object-fit: cover;
  background: #1a1a1a;
}

.app-info {
  flex: 1;
}

.app-info h2 {
  font-size: 18px;
  margin: 0;
  color: white;
  font-weight: 500;
}

.app-info p {
  font-size: 13px;
  color: #ccc;
  margin: 6px 0 2px;
}

.app-info .version {
  font-size: 12px;
  color: #888;
}

.app-card button {
  background: #0067c0;
  border: none;
  padding: 8px 16px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  color: white;
  cursor: pointer;
  transition: background 0.2s ease;
}

.app-card button:hover {
  background: #0053a3;
}

.app-card button:disabled {
  background: #444;
  cursor: default;
}
    `;
    document.head.appendChild(style);
  }

  const container = document.createElement("div");
  container.id = "app-download-ui";

  const title = document.createElement("h1");
  title.textContent = "Available Apps";
  container.appendChild(title);

  apps.forEach(([name, meta]) => {
    const card = document.createElement("div");
    card.className = "app-card";

    const img = document.createElement("img");
    img.src = (meta.icon && meta.icon.trim() !== "") ? meta.icon : "default.jpg";

    const info = document.createElement("div");
    info.className = "app-info";

    const title = document.createElement("h2");
    title.textContent = name;

    const desc = document.createElement("p");
    desc.textContent = meta.description || "No description.";

    const ver = document.createElement("div");
    ver.className = "version";
    ver.textContent = `Version: ${meta.version || "1.0"}`;

    info.appendChild(title);
    info.appendChild(desc);
    info.appendChild(ver);

    const install = document.createElement("button");

    if (installedApps.includes(`${name}.app`)) {
      install.textContent = "‚úÖ Installed";
      install.disabled = true;
    } else {
      install.textContent = "Download";
      install.onclick = () => {
        handleCommand(`installpkg "${name}"`);
        install.textContent = "‚úÖ Installed";
        install.disabled = true;
      };
    }

    card.appendChild(img);
    card.appendChild(info);
    card.appendChild(install);

    container.appendChild(card);
  });

  container.addEventListener("click", (e) => {
    if (e.target === container) container.remove();
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") container.remove();
  }, { once: true });

  document.body.appendChild(container);
  return "üõçÔ∏è App download window opened.";
});

const INTNIX_CODE = "Nebulaos1234"; // Set your master password here

registerCommand("intnixcode", () => {
  if (document.getElementById("intnix-code-ui")) {
    return "üîê Already awaiting code.";
  }

  const overlay = document.createElement("div");
  overlay.id = "intnix-code-ui";
  Object.assign(overlay.style, {
    position: "fixed",
    top: 0,
    left: 0,
    width: "100vw",
    height: "100vh",
    background: "rgba(0,0,0,0.8)",
    backdropFilter: "blur(4px)",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 99999
  });

  const box = document.createElement("div");
  Object.assign(box.style, {
    background: "#1c1c1c",
    padding: "30px",
    borderRadius: "12px",
    boxShadow: "0 0 20px rgba(0,0,0,0.5)",
    color: "white",
    fontFamily: "sans-serif",
    textAlign: "center"
  });

  const title = document.createElement("h2");
  title.textContent = "üîê Enter Intnix Authorization Code";
  title.style.marginBottom = "20px";

  const input = document.createElement("input");
  input.type = "password";
  input.placeholder = "Authorization Code";
  Object.assign(input.style, {
    padding: "10px",
    borderRadius: "6px",
    border: "none",
    width: "100%",
    marginBottom: "16px",
    fontSize: "16px",
    background: "#2a2a2a",
    color: "white"
  });

  const status = document.createElement("div");
  status.style.marginBottom = "10px";
  status.style.fontSize = "13px";
  status.style.color = "#ff6961";

  const submit = document.createElement("button");
  submit.textContent = "Authorize";
  Object.assign(submit.style, {
    padding: "10px 18px",
    fontSize: "14px",
    borderRadius: "6px",
    background: "#00bfff",
    color: "white",
    border: "none",
    cursor: "pointer"
  });

  // ‚úÖ Submit on click or Enter
  submit.onclick = () => {
    if (input.value === INTNIX_CODE) {
      localStorage.setItem("intnixCodeUnlocked", "true");
      overlay.remove();
      handleCommand("echo ‚úÖ Intnix access granted.");
    } else {
      status.textContent = "‚ùå Incorrect code.";
    }
  };

  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter") submit.click();
  });

  box.appendChild(title);
  box.appendChild(input);
  box.appendChild(status);
  box.appendChild(submit);
  overlay.appendChild(box);
  document.body.appendChild(overlay);

  return "üîê Awaiting Intnix authorization...";
});


registerCommand("quicknote", (args = []) => {
  let title = args.join(" ").trim() || `quicknote-${Date.now()}`;
  let path = `/notes/${title}.txt`;

  const note = document.createElement("div");
  Object.assign(note.style, {
    position: "fixed",
    top: "100px",
    left: "100px",
    width: "300px",
    height: "250px",
    background: "#fff8a6",
    color: "#222",
    border: "1px solid #aaa",
    borderRadius: "10px",
    boxShadow: "2px 2px 8px rgba(0,0,0,0.2)",
    padding: "10px",
    zIndex: 9999,
    fontFamily: "monospace",
    display: "flex",
    flexDirection: "column",
    resize: "both",
    overflow: "auto"
  });

  // === Top bar with title ===
  const bar = document.createElement("div");
  bar.style.cursor = "move";
  bar.style.display = "flex";
  bar.style.justifyContent = "space-between";
  bar.style.alignItems = "center";
  bar.style.marginBottom = "6px";

  const titleInput = document.createElement("input");
  titleInput.value = title;
  Object.assign(titleInput.style, {
    fontWeight: "bold",
    fontSize: "14px",
    border: "none",
    background: "transparent",
    color: "#222",
    outline: "none",
    flex: 1
  });

  const closeBtn = document.createElement("button");
  closeBtn.textContent = "‚úñ";
  Object.assign(closeBtn.style, {
    background: "none",
    border: "none",
    color: "#444",
    fontWeight: "bold",
    cursor: "pointer",
    fontSize: "16px",
    marginLeft: "6px"
  });
  closeBtn.onclick = () => note.remove();

  bar.appendChild(titleInput);
  bar.appendChild(closeBtn);

  const textarea = document.createElement("textarea");
  Object.assign(textarea.style, {
    flex: 1,
    resize: "none",
    border: "none",
    background: "transparent",
    outline: "none",
    width: "100%",
    height: "100%",
    fontSize: "14px",
    fontFamily: "monospace"
  });

  note.appendChild(bar);
  note.appendChild(textarea);
  document.body.appendChild(note);

  // === Drag Support ===
  let isDragging = false;
  let offsetX = 0;
  let offsetY = 0;

  bar.onmousedown = (e) => {
    isDragging = true;
    offsetX = e.clientX - note.offsetLeft;
    offsetY = e.clientY - note.offsetTop;
    e.preventDefault();
  };

  document.onmouseup = () => {
    isDragging = false;
  };

  document.onmousemove = (e) => {
    if (isDragging) {
      note.style.left = `${e.clientX - offsetX}px`;
      note.style.top = `${e.clientY - offsetY}px`;
    }
  };

  // === Auto Save Every 3s
  setInterval(() => {
    const content = textarea.value;
    const newTitle = titleInput.value.trim() || title;

    // Rename if changed
    if (newTitle !== title) {
      const oldPath = path;
      title = newTitle;
      path = `/notes/${title}.txt`;

      localStorage.removeItem(`fileContent:${oldPath}`);
      const notes = fakeFileSystem["/notes"];
      const oldIndex = notes.indexOf(`${title}.txt`);
      if (oldIndex !== -1) notes.splice(oldIndex, 1);
    }

    localStorage.setItem(`fileContent:${path}`, content);
    if (!fakeFileSystem["/notes"]) fakeFileSystem["/notes"] = [];
    if (!fakeFileSystem["/notes"].includes(`${title}.txt`)) {
      fakeFileSystem["/notes"].push(`${title}.txt`);
    }
  }, 3000);

  return `üìù Note "${title}" created and will auto-save.`;
});

registerCommand("launchquicknote", () => {
  const notes = fakeFileSystem["/notes"] || [];

  notes
    .filter(name => name.endsWith(".txt"))
    .forEach(name => {
      const path = `/notes/${name}`;
      const content = localStorage.getItem(`fileContent:${path}`) || "";
      const title = name.replace(".txt", "");

      const note = document.createElement("div");
      Object.assign(note.style, {
        position: "fixed",
        top: `${Math.random() * 300 + 50}px`,
        left: `${Math.random() * 500 + 50}px`,
        width: "300px",
        height: "250px",
        background: "#fff8a6",
        color: "#222",
        border: "1px solid #aaa",
        borderRadius: "10px",
        boxShadow: "2px 2px 8px rgba(0,0,0,0.2)",
        padding: "10px",
        zIndex: 9999,
        fontFamily: "monospace",
        display: "flex",
        flexDirection: "column",
        resize: "both",
        overflow: "auto"
      });

      const bar = document.createElement("div");
      bar.style.cursor = "move";
      bar.style.display = "flex";
      bar.style.justifyContent = "space-between";
      bar.style.alignItems = "center";
      bar.style.marginBottom = "6px";

      const titleInput = document.createElement("input");
      titleInput.value = title;
      Object.assign(titleInput.style, {
        fontWeight: "bold",
        fontSize: "14px",
        border: "none",
        background: "transparent",
        color: "#222",
        outline: "none",
        flex: 1
      });

      const closeBtn = document.createElement("button");
      closeBtn.textContent = "‚úñ";
      Object.assign(closeBtn.style, {
        background: "none",
        border: "none",
        color: "#444",
        fontWeight: "bold",
        cursor: "pointer",
        fontSize: "16px",
        marginLeft: "6px"
      });
      closeBtn.onclick = () => note.remove();

      bar.appendChild(titleInput);
      bar.appendChild(closeBtn);

      const textarea = document.createElement("textarea");
      Object.assign(textarea.style, {
        flex: 1,
        resize: "none",
        border: "none",
        background: "transparent",
        outline: "none",
        width: "100%",
        height: "100%",
        fontSize: "14px",
        fontFamily: "monospace"
      });

      textarea.value = content;

      note.appendChild(bar);
      note.appendChild(textarea);
      document.body.appendChild(note);

      // Drag support
      let isDragging = false;
      let offsetX = 0;
      let offsetY = 0;

      bar.onmousedown = (e) => {
        isDragging = true;
        offsetX = e.clientX - note.offsetLeft;
        offsetY = e.clientY - note.offsetTop;
        e.preventDefault();
      };

      document.onmouseup = () => {
        isDragging = false;
      };

      document.onmousemove = (e) => {
        if (isDragging) {
          note.style.left = `${e.clientX - offsetX}px`;
          note.style.top = `${e.clientY - offsetY}px`;
        }
      };

      // Auto-save reopened notes
      setInterval(() => {
        const newTitle = titleInput.value.trim() || title;
        const newPath = `/notes/${newTitle}.txt`;
        localStorage.setItem(`fileContent:${newPath}`, textarea.value);

        if (!fakeFileSystem["/notes"].includes(`${newTitle}.txt`)) {
          fakeFileSystem["/notes"].push(`${newTitle}.txt`);
        }
      }, 3000);
    });

  return `üìÇ Reopened all quicknotes.`;
});

registerCommand("openmail", () => {
  window.open("https://mail.google.com/mail/u/0/#inbox", "_blank", "popup,width=1000,height=700,left=100,top=100");
  return "üì¨ Opening Gmail in a new window...";
});

registerCommand("openyt", () => {
  window.open("https://www.youtube.com", "_blank", "popup,width=1200,height=750,left=120,top=120");
  return "‚ñ∂Ô∏è Opening YouTube in a new window...";
});

registerCommand("systemcommand", () => {
  if (document.getElementById("system-command-overlay")) {
    document.getElementById("system-command-overlay").remove();
    return "‚ùå Closed system command.";
  }

  // Style block
  if (!document.getElementById("system-command-style")) {
    const style = document.createElement("style");
    style.id = "system-command-style";
    style.textContent = `
      #system-command-overlay {
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(8px);
        z-index: 99999;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #system-command-box {
        background: rgba(40, 40, 40, 0.95);
        color: white;
        border-radius: 12px;
        padding: 16px 24px;
        font-size: 20px;
        width: 600px;
        max-width: 90vw;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
        outline: none;
        border: none;
        font-family: monospace;
      }
    `;
    document.head.appendChild(style);
  }

  const overlay = document.createElement("div");
  overlay.id = "system-command-overlay";

  const input = document.createElement("input");
  input.id = "system-command-box";
  input.type = "text";
  input.placeholder = "Enter command...";

  overlay.appendChild(input);
  document.body.appendChild(overlay);

  setTimeout(() => input.focus(), 10);

  input.addEventListener("keydown", e => {
    if (e.key === "Enter") {
      e.preventDefault();
      const cmd = input.value.trim();
      if (cmd) {
        handleCommand(cmd); // ‚úÖ use the terminal's real engine
      }
      overlay.remove();
    }
    if (e.key === "Escape") {
      overlay.remove();
    }
  });

  return "‚å®Ô∏è System Command Interface Opened.";
});

registerCommand("currentdir", () => {
  const dir = typeof currentDir === "string" ? currentDir : "/";
  return `üìÅ Current Directory: ${dir}`;
});



registerCommand("matrix", () => {
  const term = document.getElementById("terminal");
  if (!term) return "‚ùå Terminal not found.";

  if (window.matrixRunning) {
    cancelAnimationFrame(window.matrixFrame);
    term.innerHTML = window.matrixOldHTML || "";
    window.removeEventListener("keydown", window.matrixStopListener);
    window.matrixRunning = false;
    executeCommand("clear");
    createInputLine();
    return "üõë Matrix stopped.";
  }

  // Store current terminal state
  window.matrixOldHTML = term.innerHTML;
  term.innerHTML = "";

  // Create canvas overlay
  const canvas = document.createElement("canvas");
  canvas.style.position = "absolute";
  canvas.style.top = 0;
  canvas.style.left = 0;
  canvas.style.width = "100%";
  canvas.style.height = "100%";
  canvas.style.zIndex = 9999;
  term.appendChild(canvas);

  const ctx = canvas.getContext("2d");
  canvas.width = term.offsetWidth;
  canvas.height = term.offsetHeight;

  const cols = Math.floor(canvas.width / 10);
  const drops = Array(cols).fill(1);

  function drawMatrix() {
    ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#00ff88";
    ctx.font = "14px monospace";
    for (let i = 0; i < drops.length; i++) {
      const text = String.fromCharCode(0x30A0 + Math.random() * 96);
      ctx.fillText(text, i * 10, drops[i] * 14);

      if (drops[i] * 14 > canvas.height && Math.random() > 0.975)
        drops[i] = 0;
      drops[i]++;
    }

    window.matrixFrame = requestAnimationFrame(drawMatrix);
  }

  drawMatrix();
  window.matrixRunning = true;

  // Delay listener so it doesn't trigger immediately
  setTimeout(() => {
    window.matrixStopListener = () => handleCommand("matrix");
    window.addEventListener("keydown", window.matrixStopListener);

  }, 300); // 300ms buffer

  return "üü¢ Matrix started. Press any key to stop.";
});

registerCommand("reloadaerodock", () => {
  const existingDock = document.getElementById("aerodock");
  if (existingDock) existingDock.remove();

  const existingStyle = document.getElementById("aerodock-style");
  if (existingStyle) existingStyle.remove();

  // Re-run the aerodock command
  if (commands["aerodock"]) {
    return commands["aerodock"]([]);
  }

  return "‚ùå AeroDock command not found.";
});

let mediaRecorder = null;
let recordedChunks = [];

registerCommand("recordscreen", async () => {
  try {
    // Get screen stream
    const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });

    // Get selected mic ID
    const micId = localStorage.getItem("screenRecordMicId");

    // Get audio stream (from selected device or default)
    const audioStream = await navigator.mediaDevices.getUserMedia({
      audio: micId ? { deviceId: { exact: micId } } : true
    });

    // Combine screen + audio
    const combinedStream = new MediaStream([
      ...screenStream.getVideoTracks(),
      ...audioStream.getAudioTracks()
    ]);

    recordedChunks = [];
    mediaRecorder = new MediaRecorder(combinedStream, { mimeType: "video/webm" });

    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) recordedChunks.push(e.data);
    };

    mediaRecorder.start();
    return "üìπ Screen + audio recording started. Use `stoprecord` to finish.";
  } catch (err) {
    return `‚ùå Failed to start recording: ${err.message}`;
  }
});



registerCommand("stoprecord", () => {
  if (!mediaRecorder) return "‚ùå No active recording.";

  return new Promise((resolve) => {
    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, { type: "video/webm" });

      const fakeMp4Name = `Recording_${Date.now()}.mp4`;
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = fakeMp4Name; // save as .mp4 even if still webm inside
      a.click();

      // optional: store in file system
      const path = `/videos/${fakeMp4Name}`;
      if (!fakeFileSystem["/videos"]) fakeFileSystem["/videos"] = [];
      fakeFileSystem["/videos"].push(fakeMp4Name);
      localStorage.setItem("fileContent:" + path, url); // just save the blob URL for now
      saveFileSystem();

      mediaRecorder = null;
      recordedChunks = [];
      resolve(`‚úÖ Recording saved as ${fakeMp4Name}`);
    };

    mediaRecorder.stop();
  });
});


registerCommand("lookup", async (args) => {
  const match = args.join(" ").trim().match(/^\(([^)]+)\)$/);
  if (!match) return "‚ö†Ô∏è Usage: lookup (commandName)";

  const commandName = match[1].trim().toLowerCase();

  try {
    const response = await fetch("commandMeta (1).csv");
    if (!response.ok) throw new Error("Failed to load CSV");

    const csv = await response.text();
    const lines = csv.trim().split("\n");
    const headers = lines[0].split(",").map(h => h.trim().toLowerCase());

    const rows = lines.slice(1).map(line => {
      const cols = line.split(",");
      return {
        command: cols[0].trim().toLowerCase(),
        description: cols[1]?.trim(),
        version: cols[2]?.trim(),
        author: cols[3]?.trim()
      };
    });

    const entry = rows.find(row => row.command === commandName);
    if (!entry) return `‚ùì No metadata found for '${commandName}'`;

    return `üìò Command: ${entry.command}
üìù Description: ${entry.description}
üì¶ Version: ${entry.version}
üë§ Author: ${entry.author}`;
  } catch (err) {
    return "‚ùå Failed to load commandMeta.csv next to terminal.html";
  }
});



registerCommand("opencommandlist", () => {
  const path = "/stack/commandMeta.csv";
  const csv = localStorage.getItem("fileContent:" + path);

  if (!csv) return "‚ùå commandMeta.csv not found. Use `generatesheet` or `importsheet` first.";

  const blob = new Blob([csv], { type: "text/csv" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "commandMeta.csv";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  return "üì§ Downloading commandMeta.csv to your computer...";
});
registerCommand("chooseback", () => {
  const backgrounds = [
    "desktop.jpg",
    "login.jpg",
    "kingston.jpeg",
    "tent.jpg",
    "sunset.jpg",
    "quebec.jpeg",
  ];

  const winId = createWindow();
  const win = document.getElementById(winId);
  const iframe = document.getElementById(`${winId}-content`);

  // Apple-style visual container for background selector
  const content = document.createElement("div");
  content.style.display = "flex";
  content.style.flexDirection = "column";
  content.style.height = "100%";
  content.style.background = "rgba(255,255,255,0.04)";
  content.style.backdropFilter = "blur(20px)";
  content.style.padding = "20px";
  content.style.boxSizing = "border-box";
  content.style.overflowY = "auto";
  content.style.fontFamily = "sans-serif";
  content.style.color = "#fff";

  const title = document.createElement("h2");
  title.textContent = "Choose Desktop Background";
  title.style.textAlign = "center";
  title.style.marginTop = "0";
  title.style.marginBottom = "20px";
  title.style.fontWeight = "600";
  title.style.fontSize = "18px";
  title.style.color = "#fff";

  const grid = document.createElement("div");
  grid.style.display = "grid";
  grid.style.gridTemplateColumns = "repeat(auto-fit, minmax(150px, 1fr))";
  grid.style.gap = "20px";

  backgrounds.forEach(bg => {
    const card = document.createElement("div");
    card.style.borderRadius = "12px";
    card.style.background = "rgba(255,255,255,0.08)";
    card.style.boxShadow = "0 6px 20px rgba(0,0,0,0.2)";
    card.style.overflow = "hidden";
    card.style.cursor = "pointer";
    card.style.transition = "transform 0.2s ease, box-shadow 0.2s ease";
    card.onmouseover = () => {
      card.style.transform = "scale(1.03)";
      card.style.boxShadow = "0 12px 30px rgba(0,0,0,0.3)";
    };
    card.onmouseout = () => {
      card.style.transform = "scale(1)";
      card.style.boxShadow = "0 6px 20px rgba(0,0,0,0.2)";
    };

    const img = document.createElement("img");
    img.src = bg;
    img.style.width = "100%";
    img.style.height = "100px";
    img.style.objectFit = "cover";

    const label = document.createElement("div");
    label.textContent = bg;
    label.style.padding = "8px";
    label.style.textAlign = "center";
    label.style.fontSize = "12px";
    label.style.color = "#eee";

    card.onclick = () => {
      handleCommand(`setback ${bg}`);
      localStorage.removeItem("customDesktopBackground"); // clear custom if using preset
      win.remove();
      const taskBtn = document.getElementById(`taskbar-btn-${winId}`);
      if (taskBtn) taskBtn.remove();
    };

    card.appendChild(img);
    card.appendChild(label);
    grid.appendChild(card);
  });

  // Add "Choose from computer" card
  const uploadCard = document.createElement("div");
  uploadCard.style.borderRadius = "12px";
  uploadCard.style.background = "rgba(255,255,255,0.08)";
  uploadCard.style.boxShadow = "0 6px 20px rgba(0,0,0,0.2)";
  uploadCard.style.display = "flex";
  uploadCard.style.flexDirection = "column";
  uploadCard.style.justifyContent = "center";
  uploadCard.style.alignItems = "center";
  uploadCard.style.padding = "20px";
  uploadCard.style.cursor = "pointer";
  uploadCard.style.transition = "transform 0.2s ease, box-shadow 0.2s ease";
  uploadCard.onmouseover = () => {
    uploadCard.style.transform = "scale(1.03)";
    uploadCard.style.boxShadow = "0 12px 30px rgba(0,0,0,0.3)";
  };
  uploadCard.onmouseout = () => {
    uploadCard.style.transform = "scale(1)";
    uploadCard.style.boxShadow = "0 6px 20px rgba(0,0,0,0.2)";
  };

  const uploadIcon = document.createElement("div");
  uploadIcon.innerHTML = "üìÅ";
  uploadIcon.style.fontSize = "36px";
  uploadIcon.style.marginBottom = "10px";

  const uploadLabel = document.createElement("div");
  uploadLabel.textContent = "Choose from Computer";
  uploadLabel.style.textAlign = "center";
  uploadLabel.style.fontSize = "12px";
  uploadLabel.style.color = "#eee";

  uploadCard.appendChild(uploadIcon);
  uploadCard.appendChild(uploadLabel);

  uploadCard.onclick = () => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "image/*";
    input.onchange = (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = () => {
    handleCommand(`setback ${reader.result}`);
  };

        reader.readAsDataURL(file);
      }
      win.remove();
      const taskBtn = document.getElementById(`taskbar-btn-${winId}`);
      if (taskBtn) taskBtn.remove();
    };
    input.click();
  };

  grid.appendChild(uploadCard);

  content.appendChild(title);
  content.appendChild(grid);

  // Inject the content into the iframe via srcdoc
  iframe.srcdoc = `
    <style>
      body {
        margin: 0;
        background: transparent;
        font-family: sans-serif;
      }
    </style>
    <body></body>
  `;
  setTimeout(() => {
    iframe.contentDocument.body.appendChild(content);
  }, 50);

  return "üé® Background selector opened.";
});




registerCommand("settings", () => {
  const winId = createWindow("settings.html");

  // Wait for window to render, then set iframe src
  setTimeout(() => {
    const iframe = document.querySelector(`#${winId} iframe`);
    if (iframe) iframe.src = "settings.html";
  }, 0);

  return "‚öôÔ∏è Opening Settings...";
});

registerCommand("man", () => {
  const winId = createWindow("man.html");

  // Wait for window to render, then set iframe src
  setTimeout(() => {
    const iframe = document.querySelector(`#${winId} iframe`);
    if (iframe) iframe.src = "man.html";
  }, 0);

  return "üìñ Opening Manual...";
});


// üåê GlobalBridge Execution System
setInterval(() => {
  const key = "globalBridgeQueue";
  const raw = localStorage.getItem(key);
  if (!raw) return;

  let commands;
  try {
    commands = JSON.parse(raw);
  } catch (e) {
    console.error("[GlobalBridge] Invalid JSON format");
    return;
  }

  if (!Array.isArray(commands) || commands.length === 0) return;

  console.log(`[GlobalBridge] Executing ${commands.length} command(s)...`);

  commands.forEach((cmd, i) => {
    setTimeout(() => {
      console.log(`[GlobalBridge] ‚Üí ${cmd}`);
      handleCommand(cmd);
    }, i * 150); // stagger execution
  });

  // üîÅ Clear after execution
  localStorage.removeItem(key);
}, 500);

registerCommand("guipass", () => {
  const win = document.createElement("div");
  const windowId = "win_guipass";

  // Close old one if exists
  const existing = document.getElementById(windowId);
  if (existing) existing.remove();

  // ü™ü Window styling (consistent with createWindow)
  Object.assign(win.style, {
    position: "absolute",
    width: "400px",
    height: "220px",
    top: "100px",
    left: "calc(50% - 200px)",
    background: "rgba(255,255,255,0.05)",
    backdropFilter: "blur(25px)",
    borderRadius: "14px",
    border: "1px solid rgba(255,255,255,0.08)",
    boxShadow: "0 20px 40px rgba(0,0,0,0.4)",
    zIndex: zIndexCounter++,
    overflow: "hidden",
    fontFamily: "monospace",
    color: "#fff"
  });
  win.id = windowId;
  win.className = "window";

  // üßä Title Bar
  const titleBar = document.createElement("div");
  titleBar.className = "title-bar";
  titleBar.style.height = "32px";
  titleBar.style.padding = "6px 12px";
  titleBar.style.display = "flex";
  titleBar.style.justifyContent = "space-between";
  titleBar.style.alignItems = "center";
  titleBar.style.background = "rgba(255,255,255,0.08)";
  titleBar.style.backdropFilter = "blur(10px)";
  titleBar.style.borderBottom = "1px solid rgba(255,255,255,0.06)";
  titleBar.innerHTML = `<span>üîê Set Password</span><button class="close-btn" onclick="this.closest('.window').remove()">‚úñ</button>`;

  // üì¶ Content
  const content = document.createElement("div");
  Object.assign(content.style, {
    padding: "20px",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    height: "calc(100% - 32px)"
  });

  const label = document.createElement("label");
  label.textContent = "Enter new password:";
  label.style.marginBottom = "6px";

  const input = document.createElement("input");
  Object.assign(input, {
    type: "password",
    placeholder: "New password"
  });
  Object.assign(input.style, {
    padding: "8px",
    width: "80%",
    marginBottom: "10px",
    borderRadius: "6px",
    border: "1px solid #00ff88",
    background: "#111",
    color: "#00ff88",
    textAlign: "center"
  });

  const button = document.createElement("button");
  button.textContent = "Set Password";
  Object.assign(button.style, {
    padding: "8px 20px",
    borderRadius: "6px",
    border: "none",
    background: "#00ff88",
    color: "#000",
    fontWeight: "bold",
    cursor: "pointer"
  });

  const feedback = document.createElement("div");
  feedback.style.marginTop = "10px";
  feedback.style.fontSize = "14px";

  button.onclick = () => {
    const pass = input.value.trim();
    if (!currentUser) {
      feedback.textContent = "‚ùå No user signed in.";
      feedback.style.color = "#ff6666";
      return;
    }
    if (!pass) {
      feedback.textContent = "‚ùå Password cannot be empty.";
      feedback.style.color = "#ffcc00";
      return;
    }

    const targetUser = viewingUser || currentUser;
    const passwords = JSON.parse(localStorage.getItem("userPasswords") || "{}");
    passwords[targetUser] = pass;
    localStorage.setItem("userPasswords", JSON.stringify(passwords));

    feedback.textContent = `üîí Password set for user "${targetUser}"`;
    feedback.style.color = "#00ff88";
    input.value = "";
  };

  // üìé Build structure
  content.appendChild(label);
  content.appendChild(input);
  content.appendChild(button);
  content.appendChild(feedback);
  win.appendChild(titleBar);
  win.appendChild(content);
  document.body.appendChild(win);

  return "";
});

registerCommand("cc", () => {
  const winId = createWindow("commandcenter.html");

  // Wait for window to render, then set iframe src
  setTimeout(() => {
    const iframe = document.querySelector(`#${winId} iframe`);
    if (iframe) iframe.src = "commandcenter.html";
  }, 0);

  return "üß† Opening Command Center...";
});

registerCommand("pdfo", () => {
  const winId = createWindow("PDFOCR.html");

  setTimeout(() => {
    const iframe = document.querySelector(`#${winId} iframe`);
    if (iframe) iframe.src = "PDFOCR.html";
  }, 0);

  return "üìÑ Opening PDF OCR...";
});

registerCommand("anim", () => {
  const winId = createWindow("animation9.1.html");

  setTimeout(() => {
    const iframe = document.querySelector(`#${winId} iframe`);
    if (iframe) iframe.src = "animation9.1.html";
  }, 0);

  return "üéûÔ∏è Opening Animation 9.1...";
});

registerCommand("edit", () => {
  const winId = createWindow("texteditor.html");

  setTimeout(() => {
    const iframe = document.querySelector(`#${winId} iframe`);
    if (iframe) iframe.src = "texteditor.html";
  }, 0);

  return "üìù Opening Text Editor...";
});

registerCommand("appstore", () => {
  const winId = createWindow("Appstore.html");

  setTimeout(() => {
    const iframe = document.querySelector(`#${winId} iframe`);
    if (iframe) iframe.src = "Appstore.html";
  }, 0);

  return "üõçÔ∏è Opening App Store...";
});


registerCommand("nebula", () => {
  const winId = createWindow("nebula.html");

  setTimeout(() => {
    const iframe = document.querySelector(`#${winId} iframe`);
    if (iframe) iframe.src = "Nebulacode.html";
  }, 0);

  return "ü™ê Launching Nebula...";
});

function showAdPopup() {
  window.terminalAPI?.run?.("advertisement");
}

// Initial delay (1 min = 60000 ms)
setTimeout(() => {
  showAdPopup();

  // Then show every hour (1 hr = 3600000 ms)
  setInterval(() => {
    showAdPopup();
  }, 3600000);

}, 60);



registerCommand("advertisement", () => {
  const adWin = document.createElement("div");
  adWin.className = "window";
  Object.assign(adWin.style, {
    position: "absolute",
    right: "30px",
    bottom: "30px",
    width: "340px",
    height: "270px",
    background: "rgba(255, 255, 255, 0.05)",
    backdropFilter: "blur(18px)",
    WebkitBackdropFilter: "blur(18px)",
    borderRadius: "14px",
    border: "1px solid rgba(255,255,255,0.08)",
    boxShadow: "0 0 20px rgba(0,0,0,0.4)",
    zIndex: zIndexCounter++,
    fontFamily: "monospace",
    color: "white",
    overflow: "hidden",
    display: "flex",
    flexDirection: "column",
  });

  adWin.innerHTML = `
    <div style="padding: 10px 14px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.08); font-weight: bold;">
      Sponsored
      <button style="background: none; border: none; color: white; font-size: 16px; cursor: pointer;">‚ùå</button>
    </div>
    <div id="adContainer" style="flex: 1; padding: 10px; display: flex; align-items: center; justify-content: center;"></div>
  `;

  document.body.appendChild(adWin);

  // Close button logic
  adWin.querySelector("button").onclick = () => {
    document.body.removeChild(adWin);
  };

  // Add the <ins> ad tag to the adContainer
  const adContainer = adWin.querySelector("#adContainer");
  const ins = document.createElement("ins");
  ins.className = "adsbygoogle";
  ins.style.display = "block";
  ins.setAttribute("data-ad-client", "ca-pub-3263894572445801");
  ins.setAttribute("data-ad-slot", "4204054021");
  ins.setAttribute("data-ad-format", "auto");
  ins.setAttribute("data-full-width-responsive", "true");
  adContainer.appendChild(ins);

  // Load AdSense if it hasn't already
  if (!document.querySelector("script[src*='adsbygoogle.js']")) {
    const adScript = document.createElement("script");
    adScript.src = "https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3263894572445801";
    adScript.async = true;
    adScript.crossOrigin = "anonymous";
    document.head.appendChild(adScript);
  }

  // Try to render ad
  try {
    (adsbygoogle = window.adsbygoogle || []).push({});
  } catch (e) {
    console.warn("AdSense error:", e);
  }

  return "üì¢ Ad window launched.";
});


registerCommand("scanapps", async () => {
  const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || "{}");
  const appRegistry = JSON.parse(localStorage.getItem("appRegistry") || {});
  const userFS = JSON.parse(localStorage.getItem("userFileSystems") || "{}");
  const user = localStorage.getItem("currentUser") || "admin";
  const fs = userFS[user] || {};
  const apps = fs["/apps"] || [];

  let pkgMan;
  try {
    const res = await fetch("pkgMan.json");
    pkgMan = await res.json();
  } catch {
    return "‚ùå Could not load pkgMan.json.";
  }

  const toFix = [];
  let output = "üì¶ App Scan Report:\n\n";

  for (const file of apps) {
    const path = `/apps/${file}`;
    const meta = appMeta[path];
    if (!meta) {
      output += `‚ùå Missing metadata: ${file}\n`;
      continue;
    }

    const pkg = pkgMan[meta.name];
    if (!pkg) {
      output += `‚ùå Not in pkgMan: ${meta.name} (${file})\n`;
      continue;
    }

    const content = localStorage.getItem("fileContent:" + path) || "";
    const issues = [];

    if ((content.trim() !== (pkg.content || "").trim())) issues.push("HTML");
    if ((meta.icon || "").trim() !== (pkg.icon || "").trim()) issues.push("ICON");

    if (issues.length) {
      output += `üîß ${meta.name} (${file}) ‚Äî ${issues.join(", ")}\n`;
      toFix.push({ path, file, name: meta.name, newHTML: pkg.content, newIcon: pkg.icon });
    }
  }

  if (!toFix.length) return "‚úÖ All installed app HTML + icons match pkgMan.json.";

  output += `\nüõ†Ô∏è ${toFix.length} app(s) need fixing. Sync now? (y/n)`;

  const input = document.createElement("div");
  input.className = "input-line";

  const prompt = document.createElement("span");
  prompt.className = "prompt";
  prompt.textContent = "Sync> ";
  prompt.style.color = "#00ff88";

  const field = document.createElement("input");
  field.className = "cmd-input";
  field.autofocus = true;

  input.appendChild(prompt);
  input.appendChild(field);
  terminal.appendChild(document.createTextNode(output));
  terminal.appendChild(input);
  field.focus();

  field.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      const val = field.value.trim().toLowerCase();
      input.remove();

      if (val === "y" || val === "yes") {
        const appMeta = JSON.parse(localStorage.getItem("appFileMeta") || {});
        const appRegistry = JSON.parse(localStorage.getItem("appRegistry") || {});

        toFix.forEach(({ path, name, newHTML, newIcon }) => {
          localStorage.setItem("fileContent:" + path, newHTML);
          appMeta[path] = appMeta[path] || {};
          appMeta[path].icon = newIcon;
          appMeta[path].content = newHTML;

          if (appRegistry[name]) {
            appRegistry[name].icon = newIcon;
          }
        });

        localStorage.setItem("appFileMeta", JSON.stringify(appMeta));
        localStorage.setItem("appRegistry", JSON.stringify(appRegistry));

        const result = document.createElement("div");
        result.textContent = `‚úÖ Synced ${toFix.length} app(s).`;
        terminal.appendChild(result);
      } else {
        const result = document.createElement("div");
        result.textContent = "‚ùå Sync cancelled.";
        terminal.appendChild(result);
      }

      createInputLine();
    }
  });

  return "";
});

</script>
<input type="file" id="fileUploadInput" style="display: none;" />

</body>
</html>
